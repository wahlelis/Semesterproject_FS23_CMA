---
title: "Downhill Mountain biking from a movement analysis perspective"
subtitle: "Semesterproject paper for FS23 class of computational movement analysis" 
author: "Aurelia Möri, [Lisa Wahlen]"
date: "`r Sys.Date()`"
output: html_document
---


```{r include = FALSE}
# knitr::opts_chunk$set(include = FALSE)
# Length of report (approx. 15000 char (incl. spaces, incl. References list, excl. Code listing), 20000 char max)
library(wordcountaddin)
library(koRpus)
wordcountaddin:::text_stats()
```

```{r Libraries, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE)


library(readr) # to import tabular data (e.g. csv)
library(dplyr) # to manipulate (tabular) data
library(tidyr)
library(ggplot2) # to visualize data
library(gridExtra)
library(sf) # to handle spatial vector data
library(terra) # To handle raster data
library(lubridate) # To handle dates and times
library(SimilarityMeasures)
library(RColorBrewer)
library(tmap)


# BrBG palette: #a6611a, #dfc27d, #80cdc1, #018571
theme_set(theme_light())

tmap_mode("view")
```

```{r read first tour, include=FALSE}
# read Data of the example tour Wiriehorn 05-18

posmo <- read_csv("data/posmo_2023-05-18T00_00_00+02_00-2023-05-18T23_59_59+02_00.csv")

posmo <- st_as_sf(posmo, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

head(posmo)

posmo_coordinates <- st_coordinates(posmo)
posmo <- cbind(posmo, posmo_coordinates)

head(posmo) # there is an outlier. one point was recorded the night before the tour started.
# remove outlier
posmo <- posmo |> 
  slice(-1)

posmo_transport <- select(posmo, -c("weekday", "place_name", "user_id"))
posmo <- select(posmo, -c("weekday", "place_name", "transport_mode", "user_id"))
```

```{r read Wirie 0507, include=FALSE} 
# read data for Wiriehorn 05-07 for verification

wiriehorn <- read_csv("data/posmo/mtb_wiriehorn.csv")
head(wiriehorn)
wiriehorn <- st_as_sf(wiriehorn, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

wiriehorn_coordinates <- st_coordinates(wiriehorn)
wiriehorn <- cbind(wiriehorn, wiriehorn_coordinates)
head(wiriehorn)

# again there is an outlier
wiriehorn <- wiriehorn |> 
  slice(-1)

wiriehorn_transport <- select(wiriehorn, -c("weekday", "place_name", "user_id"))
```

```{r read Valbirse, include=FALSE}
# read data of the valbirse tour on 05-06

valbirse <- read_csv("data/posmo/mtb_valbirse.csv")
head(valbirse)
valbirse <- st_as_sf(valbirse, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

valbirse_coordinates <- st_coordinates(valbirse)
valbirse <- cbind(valbirse, valbirse_coordinates)
head(valbirse)

# again there is an outlier
valbirse <- valbirse |> 
  slice(-1)

valbirse_transport <- select(valbirse, -c("weekday", "place_name", "user_id"))
```


## Introduction

Mountain biking is a popular sport in Switzerland (Fischer et al., 2021), that raises both environmental and policy issues (Pröbstl-Haider et al., 2018). In order to learn more about this recreational activity, this project takes a closer look at the movement of mountain biking. The analysis of movement data has gained increasing attention from both the GIScience community and the wider public, primarily because such data is easily accessible and appears to have a simplicity in structure (Laube, 2014). Addressing this sport from a movement and spatial analysis perspective, I hope to provide some insights about this movement pattern.

Mountain biking can be practiced on different surfaces (on or off-road), but riders show a preference for natural areas (Zajc & Berzelak, 2016). There are many different types of mountain biking practices (Zajc & Berzelak, 2016), and in this project I focus on downhill mountain biking. The goal is to find the movement pattern of mountain biking in trajectories where also other movement types occurred. In order to detect the mountain biking pattern, I define three criteria which characterize downhill mountain biking. 

The criteria are:

- the speed of the riding person

- the type of ground cover on which mountain biking is performed 

- the steepness of the trajectory, which needs to be directed downhill 

The speed of a person riding a mountain bike is hard to define and may vary from 59-88 kmh (Jeremy, n.d.) to 27-32 kmh (*How Fast Do Professional Mountain Bikers Rip Down Hills?*, 2022). Other (slower) speed ranges may apply depending on personal condition and preference. Since natural areas are preferred for biking, (Zajc & Berzelak, 2016) the ground cover type needs to be vegetated or otherwise natural. Using just one or two of the criteria will still allow for other activities. For instance, a trajectory leading through grasslands and across forests could still be regarded as hiking, the same applies to the downhill movement. As the speed of a person riding a mountain bike is subject to many factors, it is also not a unique identifier for this movement pattern. Therefore, a combination of the criteria is needed to describe and detect the biking pattern. Using GPS data that Lisa Wahlen recorded on three mountainbiking tours, I will address the research questions below.

## Research Questions
In this project I will work on the following three research questions: 

- How can speed, ground cover and downward motion be used to characterize the movement pattern of downhill mountain biking?

- Can I detect segments where mountain biking occurred based on speed, groundcover and downward motion?

- Are the chosen criteria applicable to other movement trajectories?


## Data and Methods

### Datasets

For the project, I used the movement trajectories that were created by Lisa Wahlen when going mountain biking. The trajectories were recorded by using the GPS-tracking App posmo (Genossenschaft Posmo Schweiz, 2022) with a sampling rate of 10 seconds. I include 3 mountain biking tours Lisa completed in the period from the 6th of May to the 18th of May 2023. The tours were tracked in Switzerland in the areas of Wiriehorn (2 tours) and Valbirse (1 tour). 

For the assessment of the criteria that describe the movement pattern of mountain biking, we used the MOPUBE vector dataset providing the land cover types of the canton of Bern, using the version last updated on the 23.05.2023 (Amt für Geoinformation des Kantons Bern, 2023). In addidtion, we worked with parts of the swiss digital terrain model swissALTI3D (Bundesamt für Landestopografie swisstopo, 2022). This elevation data is provided as a raster in a resolution of 0.5 m in grids of 1 km^2. I worked with extracts of the datasets, covering the spatial extent of the trajectories within the Canton of Bern.

I chose the tour Lisa made on the 18th of May in the Wiriehorn area (Wiriehorn 05-18) to define the characteristics of the biking movement pattern and tried to apply the criteria to the tour at Wiriehorn on the 7th of May (Wiriehorn 05-07) and the tour in Valbirse on the 6th of May for verification. The trajectories included the car ride from Solothurn to the biking location and back. A first visualisation of transport modes of the data revealed that the mountain biking part of the trajectories were labelled by the posmo app as "Car", "Bus", "Other" - and sometimes almost correctly with "Bike". 

**Wiriehorn trajectory of the 18th of May**  
*Navigating to the south of the trajectory you'll find the mountain biking part.*
```{r echo=FALSE}
# overview transport mode

tm_shape(posmo_transport)+
  tm_dots("transport_mode")
```

**Wiriehorn trajectory of the 7th of May**  
*Navigating to the south of the trajectory you'll find the mountain biking part.*
```{r echo=FALSE}

tm_shape(wiriehorn_transport)+
  tm_dots("transport_mode")
```


**Valbirse trajectory of the 6th of May**  
*Navigating to the northeast of the trajectory you'll find the mountain biking part.*
```{r, echo=FALSE}
tm_shape(valbirse_transport)+
  tm_dots("transport_mode")
```


### Methods

Three relevant criteria for mountain biking are speed, downhill movement and ground cover. For all three criteria I assessed the values and ranges fitting the mountain biking pattern of the Wiriehorn 05-18 tour. Then I applied the criteria to the Wiriehorn 05-06 and the Valbirse tour. 

#### Speed and segmentation

```{r calculate speed, include=FALSE}
# calculate distance between points d_plusx for distance
# calculate time between points
# calculate speed
# calculate average speed between four fixes

wirie0518_speed <- posmo_transport |> 
  mutate(
    d_plus1 = sqrt((lead(X)-X)^2 + (lead(Y)-Y)^2),
    d_plus2 = sqrt((lead(X,2)-X)^2 + (lead(Y,2)-Y)^2), # new offset of 2 in function lead()
    d_minus1 = sqrt((lag(X)-X)^2 + (lag(Y)-Y)^2),
    d_minus2 = sqrt((lag(X,2)-X)^2 + (lag(Y,2)-Y)^2),
    t_plus1 = difftime(lead(datetime), datetime),
    t_plus2 = difftime(lead(datetime, 2), datetime),
    t_minus1 = difftime(lag(datetime), datetime),
    t_minus2 = difftime(lag(datetime, 2), datetime),
    s_plus1 = d_plus1/as.numeric(t_plus1), # s for speed [m/s]
    s_plus2 = d_plus2/as.numeric(t_plus2),
    s_minus1 = d_minus1/-as.numeric(t_minus1),
    s_minus2 = d_minus2/-as.numeric(t_minus2)
  )

# calculate mean speed within window of two neighboring points. not exactly a temporal window because the sampling time varies slightly. mean in m/s and km/h.

wirie0518_speed <- wirie0518_speed |>
  rowwise() |>  # so the mean per row is computed
  mutate(
    speedmean_ms = mean(c(s_plus1, s_plus2, s_minus1, s_minus2), na.rm=TRUE)
  ) |> 
  ungroup() |> # otherwise each row would represent a group, we don't want that.
  # now  we calculated the mean speed in m/s.
  # calculate mean speed in km per hour. 1 m/s = 3.6 km/h
  mutate(speedmean_kmh = speedmean_ms * 3.6)
```

```{r visual average speed, dealing with NaN, include=FALSE}
# explore what we just did
ggplot(wirie0518_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1)+
  geom_vline(xintercept = mean(wirie0518_speed$speedmean_ms, na.rm=TRUE)) # why is there no vline?

range(wirie0518_speed$speedmean_ms, na.rm=TRUE)

wirie0518_speed$speedmean_ms[1:50] # how did i get inf and NaN values? something divided by 0 returns inf. 0/0 returns NaN. no vline because of nan values
pt <- is.finite(wirie0518_speed$speedmean_ms) # returns TRUE if it is not one of the values NA, NaN, Inf or -Inf
length(pt[pt == FALSE]) # counts NA, NaN, Inf and -Inf. we have 80 of those

# plot points with inf and non numeric value. let's see which points are affected.

inf_filter <- wirie0518_speed |> 
  filter(!is.finite(speedmean_ms))

tm_shape(wirie0518_speed)+
  tm_dots()+
  tm_shape(inf_filter)+
  tm_dots("transport_mode")

# of 2,237 rows only 80 rows are affected (3.58 %). since the +-Inf, NaN and NA values emerge where either the distance or the time between two points is 0, the points in question seem to be static (either temporally or locally). where no speed can be computed, no evaluation regarding a threshold can be taken. 
# the inf/NaN/NA points are located where little movement is plausible (at the bottom and the top of the cable car allmiried, somewhere in the middle of the downhill trail, at train stations in Solothurn). 

# new dataset to create segmentation
wirie0518_segments <- wirie0518_speed |> 
    mutate(static = !is.finite(wirie0518_speed$speedmean_ms)) # returns TRUE for static points

# "clean" dataset for visualisation of moving point parameter profile
wirie0518_speed <- wirie0518_speed |>
  filter(is.finite(speedmean_ms))

ggplot(wirie0518_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(wirie0518_speed$speedmean_ms), col = "#a6611a") # vline is visible, average speed on that day was around 10 m/s

ggplot(wirie0518_speed, aes(speedmean_kmh))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(wirie0518_speed$speedmean_kmh), col = "#a6611a") # vline is visible, average speed on that day was around 37.33548 km/h

mean(wirie0518_speed$speedmean_kmh)

# # static points visualisation
# where are the static points in the allmiried area? i see static points at the talstation, bergstation and halfway on the trail. (breaks to wait for each other, slow movements waiting for the funiculare)
tm_shape(wirie0518_segments)+
  tm_dots("static")
```

For every fix on the trajectory I calculated the average speed within the window of four neighboring points, similar to the moving window method of Laube & Purves (2011). The euclidean distance to the two points before and the two points after the fix was calculated and divided by the time difference between the fix and the two points before and after, respectively. Fixes where the speed calculation could not be completed because either the distance or the time between two points was 0, were regarded as static. On the Wiriehorn 05-18 tour, 80 points were labelled as static, and used for segmentation of the trajectory. They were located in places on the trajectory where little movement or a change in transport mode is plausible (e.g. at the bottom and the top of the cable car allmiried, somewhere in the middle of the downhill trail, at train stations in Solothurn). The segments were used to identify parts of the trajectory where Lisa was mountain biking. The relevant segments were selected based on visual assessment of the movement parameter profile (Dodge et al. 2009) of the average speed (Figure below). I assumed that Lisa went biking between 8:30 and 13:30, and that very short segments and segments with high velocities do not represent biking.


```{r MPP speed, include=FALSE}
#### moving parameter (MP) profile, visualisation of static points 
# for speed (Dodge et al., 2009)

ggplot(wirie0518_speed, aes(x = datetime, y = speedmean_kmh))+
  geom_path(col = "#a6611a" )+
  geom_point(col ="#dfc27d", alpha = .2)+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile for average speed", subtitle = "Wiriehorn tour 05-18")

```

```{r segmentation function, include=FALSE}
#### Segmentation
# function for assigning unique ID to the subtrajectories

rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

wirie0518_segments <- wirie0518_segments |> 
  mutate(ID=rle_id(static))
```

```{r moving segments, include=FALSE}
# Visualize the moving segments by colourizing them by segment_ID.

wirie0518_segments <- wirie0518_segments |> 
  filter(!static) # select rows where the static value is not TRUE to select the moving segments

ggplot(wirie0518_segments, aes(X, Y))+
  geom_path(aes(color=ID))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  labs(title= "Moving segments by ID", subtitle = "Wiriehorn 05-18")

# MP profile
ggplot(wirie0518_segments, aes(x = datetime, y = speedmean_kmh))+
  geom_line(aes(color = ID))+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile of average speed", subtitle = "moving segments of Wiriehorn 05-18")
```

```{r MPP segments, echo=FALSE}
# MP profile
ggplot(wirie0518_segments, aes(x = datetime, y = speedmean_kmh))+
  geom_line(aes(color = ID))+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile of average speed", subtitle = "moving segments of Wiriehorn 05-18")
```


However, the selected segments included the movement of the cable car Lisa took to get uphill to the trail start.
To isolate the cable car and determine the relevant speed range for mounainbiking, the average speed distribution of the selected segments was calculated. The speed values that best characterized the movement of mountain biking were identified through a process of testing. 


```{r choosing segments and defining range, include = FALSE}

# looks like the segments 12, 14, 16, 18, 20, 22, 24, 26 are mountain biking segments
wirie0518_threshold <- wirie0518_segments |> 
  filter(ID == c(12, 14, 16, 18, 20, 22, 24, 26))

ggplot(wirie0518_threshold, aes(X, Y))+
  geom_point(aes(color=ID))+
  geom_path(aes(color=ID))+
  coord_fixed()

# covers the time range between 08:42 - 13:13 which corresponds to biking
# figure out which speed range makes sense to define mountain biking

ggplot(wirie0518_threshold, aes(y=speedmean_kmh))+
  geom_boxplot(color="#a6611a", fill="#dfc27d", alpha=0.2)+
  ylab("mean speed [kmh]")+
  scale_x_discrete(labels = NULL, breaks = NULL)+
  labs(title = "Average speed distribution of mountain biking segments", subtitle = "Wiriehorn 05-18")

summary(wirie0518_threshold$speedmean_kmh)
summary(wirie0518_threshold$speedmean_ms)
sd(wirie0518_threshold$speedmean_kmh)
```

```{r rename / overwrite rows of points within the speed range of mountain biking, include=FALSE}

# wirie0518_speed$transport_mode[wirie0518_speed$speedmean_kmh >= 2.855 & wirie0518_speed$speedmean_kmh <= 10.308] <- "mtb"
# 
# tm_shape(wirie0518_speed)+
#   tm_dots("transport_mode")

# zooming into the allmiried area we can see that the cable car is labelled as mtb. the speed range therefore applies mainly to the cable car. let's see if by adjusting the range to include lower values as the set threshold changes anything.

# wirie0518_speed$transport_mode[wirie0518_speed$speedmean_kmh <= 10.308] <- "mtb"
# 
# tm_shape(wirie0518_speed)+
#   tm_dots("transport_mode")

# a few more points are included, a great deal of the downhill parts are still not covered though. adjust upper threshold, choose max value of statistics output above. exclude range of cable car

wirie0518_speed$transport_mode[wirie0518_speed$speedmean_kmh < 26.95490 & !(wirie0518_speed$speedmean_kmh >= 2.855 & wirie0518_speed$speedmean_kmh <= 10.308)] <- "mtb"

# tm_shape(wirie0518_speed)+
#   tm_dots("transport_mode")

# zooming in the map, we see that the cable car is excluded in the allmiried area. since the walking speed of 4-5kmh is also excluded, the transport mode "walking" is preserved. however, some points on the mountainbike descent are excluded, probably because they fall in the speed range of the cable car. otherwise, the result represents most of the downhill mountain biking.

wirie0518_segments$transport_mode[wirie0518_segments$speedmean_kmh <= 26.95490 & !(wirie0518_segments$speedmean_kmh >= 2.855 & wirie0518_segments$speedmean_kmh <= 10.308)] <- "mtb"

# ggplot(wirie0518_threshold, aes(x = datetime, y = speedmean_kmh))+
#   geom_path(color="#a6611a")+
#   geom_point(col ="#dfc27d", alpha = .6)+
#   ylab("average speed [km/h]")+
#   xlab("time")+
#   labs(title = "Movement parameter profile for average speed", subtitle = "mountainbike segments Wiriehorn tour 05-18")

```

```{r try it on moving segments, include=FALSE}
wirie0518_segments$transport_mode[wirie0518_segments$speedmean_kmh <= 26.95490 & !(wirie0518_segments$speedmean_kmh >= 2.855 & wirie0518_segments$speedmean_kmh <= 10.308)] <- "mtb"

wirie0518_segments <- wirie0518_segments |> 
  mutate(mtb_speed = transport_mode =="mtb")

length(wirie0518_segments$mtb_speed[wirie0518_segments$mtb_speed == TRUE]) # 605 true

```

#### Ground cover

The MOPUBE dataset showed 22 ground cover types (see figure below). Knowing about the preference for natural contexts for mountain biking (Zajc & Berzelak, 2016) I assume that Lisa rode on vegetated and/or natural groundcovers. Thus, every groundcover type seems suitable except for "Abbau, Deponie", Bahn", "Gebäude", "Strasse, Weg", "Trottoir", "übrige befestigte" and "Verkehrsinsel". We could argue that water bodies are not suitable as well, but depending on their size it is not impossible to cross such features when biking.


```{r read ground cover data, echo = FALSE}
bodenbedeckung <- read_sf("data/shapefiles/MOPUBE_traj.shp")
# head(bodenbedeckung)

# remove columns that are not required

bodenbedeckung <- bodenbedeckung |> 
  transmute(BBFID = BBFID,
            groundcover = BBARTT_BEZ,
            geometry = geometry)

# unique(bodenbedeckung$groundcover)

tm_shape(bodenbedeckung)+
  tm_polygons("groundcover")+
  tmap_options(check.and.fix = TRUE)+
  tm_view(set.view = c(7.54170, 46.60981, 14))
```

```{r intersect the trajectory dataset, include=FALSE}

wirie0518_gc <- st_intersection(wirie0518_segments, bodenbedeckung)

# head(wirie0518_gc)
# display values occurring on the trajectory.

tm_shape(wirie0518_gc)+
  tm_dots("groundcover")+
  tmap_options(check.and.fix = TRUE)
```

```{r all natural gc types and true false vector for gc, include=FALSE}
# vector with all ground cover types including natural / vegetated features.
mountainbike <- c("Acker, Wiese, Weide", "Fels", "fliessendes Gewässer", "Gartenanlage", "Geröll, Sand", "geschlossener Wald", "Schilfgürtel", "Stehendes Gewässer", "übrige bestockte", "übrige humusierte", "übrige Intensivkultur", "übrige vegetationslose", "Wasserbecken", "Wytweide dicht", "Wytweide offen")

wirie0518_gc <- wirie0518_gc |>
  mutate(mtb_gc = groundcover %in% mountainbike) # mountainbike ground cover TRUE/FALSE vector
```


To determine on which parts of the trajectory Lisa moved offroad, I intersected the ground cover dataset MOPUBE and the movement points. This reduced the trajectories to the spatial extent of the Canton of Bern, therefore excluding parts of the car ride from and to Solothurn. This step called track annotation (Dodge et al., 2013) allowed to add environmental information to the points on the trajectory. All points associated with natural ground cover were considered as matching the criteria and labelled accordingly.

#### Downhill movement

```{r import elevation data, include=FALSE}
# list takes all files with .tif from a folder
file_list <- list.files("data/alti3D_all_inc/",".tif",full.names = TRUE)

# makes a virtual raster layer from the files
vrt(file_list, "altivrt.vrt",overwrite = TRUE)

# import the data from the virtual raster layer
alti <- rast("altivrt.vrt")

# check if extent matches the trajectories
# plot(alti)
# plot(wirie0518_speed, add=TRUE)
# plot(valbirse, add=TRUE)

```

```{r annotate elevation to groundcover, include=FALSE}
wirie0518_alti <- wirie0518_gc |> 
  mutate(hoehe = terra::extract(alti, wirie0518_gc)) # extract values froam a Raster for a set of locations. becauses function "extract" is masked from the tidyr library, the terra pkg needs to be specified

wirie0518_alti <- wirie0518_alti[order(wirie0518_alti$datetime, decreasing = FALSE),]

ggplot(data= wirie0518_alti, aes(datetime, hoehe$altivrt))+
  geom_point(aes(color = groundcover))+
  geom_path()+
  labs(title = "Height change over time and ground cover of trajectory", subtitle = "Wiriehorn 05-18")+
  ylab("altitude [m.a.s.l.]")+
  xlab("time")
```

```{r calculate and add height difference criteria, include=FALSE}
wirie0518_alti <- wirie0518_alti|> 
  mutate(h_plus4 = (lead(hoehe$altivrt, 4)- hoehe$altivrt))

## if the next fix (within a window of 40 secs) is located at a lower altitude, the movement goes downhill. if the value of the difference between the following fix and the current fix is negative, i assume the movement goes downward.

## where sum is smaller than 0 we have a descent
wirie0518_alti <- wirie0518_alti |> 
  mutate(mtb_elevation = h_plus4 < 0)

tm_shape(wirie0518_alti)+
  tm_dots("mtb_elevation")

wirie0518_alti <- na.omit(wirie0518_alti) # remove the four lead() NAs
# TRUE means downward movement (negative elevation difference between two fixes)

# since the car ride includes movement in both directions, it shows both values vor upwards and downwards. 
```

The elevation data was added to the dataset of the Wiriehorn 05-18 trajectory and the difference in elevation to the fourth point after the fix in the direction of movement was calculated. If within this 40 second window the difference in altidude was negative, it is assumed to be downhill movement.

#### Combination of criteria and refining steps

```{r wirie0518 combining all criteria, include=FALSE}
wirie0518 <- wirie0518_alti |> 
  select(datetime, ID, mtb_speed, mtb_gc, mtb_elevation, X, Y, geometry) |> 
  rowwise() |> 
  mutate(mtb = sum(mtb_speed, mtb_gc, mtb_elevation, na.rm=TRUE)) |> 
  ungroup()

# head(wirie0518)
# wirie0518 <- na.omit(wirie0518)
# 
# tm_shape(wirie0518)+
#   tm_dots("mtb", palette= brewer.pal(4, "BrBG"))+
#   tm_view(set.view = c(7.54170, 46.60981, 14))

# green values show how many criteria apply for the fix

```

```{r wirie0518 quantifying, include=FALSE}
length(wirie0518_alti$mtb_speed[wirie0518_alti$mtb_speed == TRUE]) # 493 true
length(wirie0518_alti$mtb_gc[wirie0518_alti$mtb_gc == TRUE]) # 880 true
length(wirie0518_alti$mtb_elevation[wirie0518_alti$mtb_elevation == TRUE]) # 821 true

wirie0518 <- wirie0518 |>
  mutate(mtb_count3 = mtb == 3)

length(wirie0518$mtb_count3[wirie0518$mtb_count3 == TRUE]) # 339 true

wirie0518_summary <- wirie0518 |>
  select(ID, mtb) |>
  group_by(ID) |>
  summarise(n_1 = sum(mtb==3),
            n_2 = sum(mtb==2),
            n_3 = sum(mtb==1)
            # sumcriteria = sum(mtb),
            # tourtime=difftime(last(datetime), first(datetime))
            )

# wirie0518_sumlong <- pivot_longer(wirie0518_summary, 2:4,
#                names_to = "criteria",
#                values_to = "points")
# 
# ggplot(wirie0518_sumlong, aes(fill = criteria, x = ID, y = points)) +
#   geom_bar(position = "stack", stat = "identity") +
#   scale_fill_manual(values = c("n_1" = "#dfc27d",
#                                "n_2" = "#80cdc1",
#                                "n_3" = "#018571"
#                                ))+
#   xlab("Segment ID")+
#   ylab("number of points on trajectory")+
#   labs(title = "Number of criteria applying to segments", subtitle = "Wiriehorn 05-18")+
#   geom_text(data=subset(wirie0518_sumlong,points > 5), aes(label = points), stat = "identity", colour = "black", position = position_stack(vjust = 0.5), size=2)
```

For every point on the trajectory I displayed how many of the three criteria applied. Based on the count of matching criteria, I isolated new segments that represent downhill mountain biking. To be considered for a mountain biking segment, a point on the trajectory had to meet the following conditions: The neighboring four fixes must show a sum of at least 6 matched criteria, and, within a window of one minute, there is at least one fix that matches all three of the criteria. 

```{r wirie0518 new segmentation, include=FALSE}

wirie0518_try <- wirie0518 |> 
  mutate(
    min3 = lead(mtb_count3) == TRUE |lead(mtb_count3,2)==TRUE |lead(mtb_count3,3) == TRUE | lag(mtb_count3) == TRUE | lag(mtb_count3,2)==TRUE | lag(mtb_count3,3)==TRUE
  ) # innerhalb einer minute muss mindestens einmal der Wert drei vorkommen - also drei kriterien erfüllt sein. 

# tm_shape(wirie0518_try)+
#   tm_dots("min3")

wirie0518_try <- wirie0518_try |>
  mutate(
    c_plus1 = lead(mtb),
    c_plus2 = lead(mtb,2), # new offset of 2 in function lead()
    c_minus1 = lag(mtb),
    c_minus2 = lag(mtb,2)
  ) # berechnen, wie viele kriterien bei den benachbarten punkten zutreffen und so versuchen, die punkte wo weniger kriterien zutreffen, aussschliessen. ausreichend bike punkte eingeschlossen, die nicht alle kriterien erfüllen

wirie0518_try <- wirie0518_try |> 
  rowwise() |> 
  mutate(c_sum = sum(c(c_plus1, c_plus2, c_minus1, c_minus2))) |> 
  ungroup()

wirie0518_try <- wirie0518_try |> 
  mutate(mtb_sum = c_sum >= 6) |> 
  mutate(mtb_refined = mtb_sum == TRUE & min3 == TRUE)

# tm_shape(wirie0518_try)+
#   tm_dots("mtb_sum")

tm_shape(wirie0518_try)+
  tm_dots("mtb_refined")

# new segmentation
wirie0518_try <- wirie0518_try |> 
  mutate(ID_mtb=rle_id(mtb_refined))

wirie0518_try <- na.omit(wirie0518_try)
```


## Results

### Wiriehorn 05-18 

On the Wiriehorn 05-18 trajectory, the points where I assumed Lisa went mountain biking generally show a higher count of criteria matched. The straight line uphill represents the cable car, the sinuously distributed points represent the presumed biking pattern. Depending on the criteria, some points on the trajectory received a higher count.

**Wiriehorn 05-18. Number of matched criteria for mountain biking (mtb) for each point.**
```{r Wiriehorn 0518 overview, echo=FALSE}
tm_shape(wirie0518)+
  tm_dots("mtb", palette= brewer.pal(4, "BrBG"))+
  tm_view(set.view = c(7.54170, 46.60981, 14))
```


**Wiriehorn 05-18. Speed (mtb_speed), groundcover (mtb_gc), downwards movement (mtb_elevation)**
```{r facets of every criteria Wirie0518, echo=FALSE}
tm_shape(wirie0518)+
  tm_dots(col = c("mtb_speed", "mtb_gc", "mtb_elevation"), palette=c('#a6611a', '#80cdc1'))+
  tm_facets(sync = TRUE, ncol = 3)+
  tm_view(set.view = c(7.53338, 46.60628, 14))
```

```{r "speed movement parameter plots", include=FALSE}

speed <- ggplot(wirie0518_alti, aes(x = datetime, y = speedmean_kmh))+
  geom_line()+
  geom_point(aes(col=mtb_speed))+
  theme(legend.position=c(0.5,0.8), plot.margin = unit(c(0,0,0,0), "lines"),
            plot.background = element_blank())

groundcover <- ggplot(wirie0518_alti, aes(x = datetime, y = speedmean_kmh))+
  geom_line()+
  geom_point(aes(col=mtb_gc))+
  theme(legend.position= c(0.5,0.8), axis.text.y = element_blank(), 
            axis.ticks.y = element_blank(), 
            axis.title.y = element_blank(),
            plot.margin = unit(c(0,0,0,0), "lines"),
            plot.background = element_blank())

elevation <- ggplot(wirie0518_alti, aes(x = datetime, y = speedmean_kmh))+
  geom_line()+
  geom_point(aes(col=mtb_elevation))+
  theme(legend.position=c(0.5,0.8),axis.text.y = element_blank(), 
            axis.ticks.y = element_blank(), 
            axis.title.y = element_blank(),
            plot.margin = unit(c(0,0,0,0), "lines"),
            plot.background = element_blank())

grid.arrange(speed, groundcover, elevation, ncol=3)
```

  
After applying the refining criteria, the basis for the new segmentation included all of the downhill biking trajectory except for 11 points.  

**Wiriehorn 05-18 trajectory. The points matching the refined criteria return TRUE.**
```{r basis for new segmentation, echo=FALSE}
tm_shape(wirie0518_try)+
  tm_dots("mtb_refined", palette=c('#a6611a', '#80cdc1'))+
  tm_view(set.view = c(7.54170, 46.60981, 14))
```

The results of the second segmentation step represent the mountain biking pattern. Segments where Lisa went biking could be isolated. 


```{r new segmentation, echo=FALSE}
wirie0518_try <- wirie0518_try |>
  filter(mtb_refined==TRUE) # select rows where the value is TRUE to select the downhill mountain biking segments

ggplot(wirie0518_try, aes(X, Y))+
  geom_path(aes(color=ID_mtb))+
  geom_point(aes(color = ID_mtb))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.key.size = unit(1, 'cm'),
        legend.key.height = unit(.5, 'cm'), #change legend key height
        legend.key.width = unit(1, 'cm'), #change legend key width
        legend.title = element_text(size=9), #change legend title font size
        legend.text = element_text(size=6))+
  labs(title = "New segments based on refined criteria", subtitle = "Wiriehorn 05-18")
```

### Application to other movement trajectories
#### Wiriehorn 05-07

```{r wirie 0507 speed, include=FALSE}
# calculate distance between points d_plusx for distance
# calculate time between points
# calculate speed
# calculate average speed between four fixes

wirie0507_speed <- wiriehorn_transport |> 
  mutate(
    d_plus1 = sqrt((lead(X)-X)^2 + (lead(Y)-Y)^2),
    d_plus2 = sqrt((lead(X,2)-X)^2 + (lead(Y,2)-Y)^2), # new offset of 2 in function lead()
    d_minus1 = sqrt((lag(X)-X)^2 + (lag(Y)-Y)^2),
    d_minus2 = sqrt((lag(X,2)-X)^2 + (lag(Y,2)-Y)^2),
    t_plus1 = difftime(lead(datetime), datetime),
    t_plus2 = difftime(lead(datetime, 2), datetime),
    t_minus1 = difftime(lag(datetime), datetime),
    t_minus2 = difftime(lag(datetime, 2), datetime),
    s_plus1 = d_plus1/as.numeric(t_plus1), # s for speed [m/s]
    s_plus2 = d_plus2/as.numeric(t_plus2),
    s_minus1 = d_minus1/-as.numeric(t_minus1),
    s_minus2 = d_minus2/-as.numeric(t_minus2)
  )

# calculate mean speed within window of two neighboring points. not exactly a temporal window because the sampling time varies slightly. mean in m/s and km/h.

wirie0507_speed <- wirie0507_speed |>
  rowwise() |>  # so the mean per row is computed
  mutate(
    speedmean_ms = mean(c(s_plus1, s_plus2, s_minus1, s_minus2), na.rm=TRUE)
  ) |> 
  ungroup() |> 
  mutate(speedmean_kmh = speedmean_ms * 3.6) # calculate mean speed in km per hour. 1 m/s = 3.6 km/h
```

```{r wirie 0507 visualisation of average speed, dealing with NaN, include=FALSE}
# explore what we just did
ggplot(wirie0507_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1)+
  geom_vline(xintercept = mean(wirie0507_speed$speedmean_ms, na.rm=TRUE)) # why is there no vline?

range(wirie0507_speed$speedmean_ms, na.rm=TRUE)

wirie0507_speed$speedmean_ms[1:60] 
pt <- is.finite(wirie0507_speed$speedmean_ms) # returns TRUE if it is not one of the values NA, NaN, Inf or -Inf
length(pt[pt == FALSE]) # counts NA, NaN, Inf and -Inf. we have 30 of those

# plot points with inf and non numeric value. let's see which points are affected.

inf_filter <- wirie0507_speed |> 
  filter(!is.finite(speedmean_ms))

tm_shape(wirie0507_speed)+
  tm_dots()+
  tm_shape(inf_filter)+
  tm_dots("transport_mode")

# of 1.174 rows only 30 rows are affected (2,56 %). since the +-Inf, NaN and NA values emerge where either the distance or the time between two points is 0, the points in question seem to be static (either temporally or locally). where no speed can be computed, no evaluation regarding a threshold can be taken. 
# the inf/NaN/NA points are located where little movement is plausible (at the bottom and the top of the cable car allmiried). 

# new dataset to create segmentation
wirie0507_segments <- wirie0507_speed |> 
    mutate(static = !is.finite(wirie0507_speed$speedmean_ms)) # returns TRUE for static points

# "clean" dataset for visualisation of moving point parameter profile
wirie0507_speed <- wirie0507_speed |>
  filter(is.finite(speedmean_ms))

ggplot(wirie0507_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(wirie0507_speed$speedmean_ms), col = "#a6611a") # vline is visible, average speed on that day was around 10 m/s

ggplot(wirie0507_speed, aes(speedmean_kmh))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(wirie0507_speed$speedmean_kmh), col = "#a6611a") # vline is visible, average speed on that day was around 43.68436 km/h

mean(wirie0507_speed$speedmean_kmh)
```

```{r wirie 0507 assign uique IDs and visualize them, include=FALSE}

wirie0507_segments <- wirie0507_segments |> 
  mutate(ID=rle_id(static))

ggplot(wirie0507_segments, aes(X, Y))+
  geom_path(aes(color=ID))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

### Visualize the moving segments by colourizing them by segment_ID.

wirie0507_segments <- wirie0507_segments |> 
  filter(!static) # select rows where the static value is not TRUE to select the moving segments

ggplot(wirie0507_segments, aes(X, Y))+
  geom_path(aes(color=ID))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# check MP profile
ggplot(wirie0507_segments, aes(x = datetime, y = speedmean_kmh))+
  geom_line(aes(color = ID))+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile of average speed", subtitle = "moving segments of Wiriehorn 05-07")

# cable car not excluded
```

```{r wirie 0507 rename overwrite rows of points within the speed range of mountain biking, include=FALSE}
wirie0507_speed$transport_mode[wirie0507_speed$speedmean_kmh <= 26.95490 & !(wirie0507_speed$speedmean_kmh >= 2.855 & wirie0507_speed$speedmean_kmh <= 10.308)] <- "mtb"

tm_shape(wirie0507_speed)+
  tm_dots("transport_mode")

wirie0507_segments$transport_mode[wirie0507_segments$speedmean_kmh <= 26.95490 & !(wirie0507_segments$speedmean_kmh >= 2.855 & wirie0507_segments$speedmean_kmh <= 10.308)] <- "mtb"

wirie0507_segments <- wirie0507_segments |> 
  mutate(mtb_speed = transport_mode =="mtb")

length(wirie0507_segments$mtb_speed[wirie0507_segments$mtb_speed == TRUE]) # 241 true

tm_shape(wirie0507_segments)+
  tm_dots("transport_mode")
```

```{r wirie 0507 ground cover, include=FALSE}

wirie0507_gc <- st_intersection(wirie0507_segments, bodenbedeckung)

head(wirie0507_gc)
# display values occurring on the trajectory.
unique(wirie0507_gc$groundcover)

# tm_shape(wirie0507_gc)+
#   tm_dots("groundcover")

wirie0507_gc <- wirie0507_gc |>
  mutate(mtb_gc = groundcover %in% mountainbike) # mountainbike ground cover TRUE/FALSE vector

# tm_shape(wirie0507_gc)+
#   tm_dots("mtb_gc")
```

```{r wirie 0507 elevation difference, include=FALSE}
wirie0507_alti <- wirie0507_gc |> 
  mutate(hoehe = terra::extract(alti, wirie0507_gc)) # extract values froam a Raster for a set of locations.

# posmo_annotated <- na.omit(posmo_annotated)

wirie0507_alti <- wirie0507_alti[order(wirie0507_alti$datetime, decreasing = FALSE),]

ggplot(data= wirie0507_alti, aes(datetime, hoehe$altivrt))+
  geom_point(aes(color = groundcover))+
  geom_path()+
  labs(title = "Height change over time and ground cover of trajectory", subtitle = "Wiriehorn 05-18")+
  ylab("altitude [m.a.s.l.]")+
  xlab("time")


wirie0507_alti <- wirie0507_alti|> 
  mutate(h_plus4 = (lead(hoehe$altivrt, 4)- hoehe$altivrt))

## where sum is smaller than 0 we have a descent
wirie0507_alti <- wirie0507_alti |> 
  mutate(mtb_elevation = h_plus4 < 0)

wirie0507_alti <- na.omit(wirie0507_alti) # omit the four lead() values

# tm_shape(wirie0507_alti)+
#   tm_dots("mtb_elevation")
```

```{r combination of criteria, quantification, include=FALSE}
wirie0507 <- wirie0507_alti |> 
  select(ID, datetime, mtb_speed, mtb_gc, mtb_elevation, X, Y, geometry) |> 
  rowwise() |> 
  mutate(mtb = sum(mtb_speed, mtb_gc, mtb_elevation, na.rm=TRUE)) |> 
  ungroup()

head(wirie0507)

tm_shape(wirie0507)+
  tm_dots("mtb", palette= brewer.pal(4, "BrBG"))

length(wirie0507_alti$mtb_speed[wirie0507_alti$mtb_speed == TRUE]) # 234 true (of 1015 rows)
length(wirie0507_alti$mtb_gc[wirie0507_alti$mtb_gc == TRUE]) # 516 true
length(wirie0507_alti$mtb_elevation[wirie0507_alti$mtb_elevation == TRUE]) # 476 true


wirie0507 <- wirie0507 |> 
  mutate(mtb_count3 = mtb == 3)

length(wirie0507$mtb_count3[wirie0507$mtb_count3 == TRUE]) # 318 true

wirie0507_summary <- wirie0507 |> 
  select(ID, mtb) |> 
  group_by(ID) |> 
  summarise(n_1 = sum(mtb==3),
            n_2 = sum(mtb==2),
            n_3 = sum(mtb==1)
            # sumcriteria = sum(mtb),
            # tourtime=difftime(last(datetime), first(datetime))
            )

# wirie0507_sumlong <- pivot_longer(wirie0507_summary, 2:4,
#                names_to = "criteria",
#                values_to = "points")
```

Also on the Wiriehorn 05-07 trajectory, a higher count of criteria matched is visible where Lisa went mountain biking. The count varies depending on the criteria.

**Wiriehorn 05-07. Number of matched criteria for mountain biking (mtb) for each point.**
```{r wirie0507 all criteria, echo=FALSE}
tm_shape(wirie0507)+
  tm_dots("mtb", palette= brewer.pal(4, "BrBG"))+
  tm_view(set.view = c(7.54170, 46.60981, 14))
```


**Wiriehorn 05-17. Speed (mtb_speed), groundcover (mtb_gc), downwards movement (mtb_elevation).**
```{r facets of every criteria Wirie0507, echo=FALSE}
tm_shape(wirie0507)+
  tm_dots(col = c("mtb_speed", "mtb_gc", "mtb_elevation"), palette=c('#a6611a', '#80cdc1'))+
  tm_facets(sync = TRUE, ncol = 3)+
  tm_view(set.view = c(7.53338, 46.60628, 14))
```

```{r wirie 0507 new segmentation, include=FALSE}

wirie0507_try <- wirie0507 |> 
  mutate(
    min3 = lead(mtb_count3) == TRUE |lead(mtb_count3,2)==TRUE |lead(mtb_count3,3) == TRUE | lag(mtb_count3) == TRUE | lag(mtb_count3,2)==TRUE | lag(mtb_count3,3)==TRUE
  ) # innerhalb einer minute muss mindestens einmal der Wert drei vorkommen - also drei kriterien erfüllt sein. 

tm_shape(wirie0507_try)+
  tm_dots("min3")

wirie0507_try <- wirie0507_try |>
  mutate(
    c_plus1 = lead(mtb),
    c_plus2 = lead(mtb,2), # new offset of 2 in function lead()
    c_minus1 = lag(mtb),
    c_minus2 = lag(mtb,2)
  ) # berechnen, wie viele kriterien bei den benachbarten punkten zutreffen und so versuchen, die punkte wo weniger kriterien zutreffen, aussschliessen. ausreichend bike punkte eingeschlossen, die nicht alle kriterien erfüllen

wirie0507_try <- wirie0507_try |> 
  rowwise() |> 
  mutate(c_sum = sum(c(c_plus1, c_plus2, c_minus1, c_minus2))) |> 
  ungroup()

wirie0507_try <- wirie0507_try |> 
  mutate(mtb_sum = c_sum >= 6) |> 
  mutate(mtb_refined = mtb_sum == TRUE & min3 == TRUE)

tm_shape(wirie0507_try)+
  tm_dots("mtb_sum")

tm_shape(wirie0507_try)+
  tm_dots("mtb_refined")

wirie0507_try <- wirie0507_try |> 
  mutate(ID_mtb=rle_id(mtb_refined))

tm_shape(wirie0507_try)+
  tm_dots("mtb_refined")+
  tm_shape(wirie0507_try)+
  tm_dots("ID_mtb")

wirie0507_try <- na.omit(wirie0507_try)
```


**Wiriehorn 05-07 trajectory. The points matching the refined criteria return TRUE.**
```{r wirie 0507 basis for new segmentation, echo=FALSE}
tm_shape(wirie0507_try)+
  tm_dots("mtb_refined", palette=c('#a6611a', '#80cdc1'))+
  tm_view(set.view = c(7.54170, 46.60981, 14))
```

 
```{r wirie0507 new segmentation and visualisation, echo=FALSE}
wirie0507_try <- wirie0507_try |>
  filter(mtb_refined==TRUE) # select rows where the static value is not TRUE to select the moving segments

ggplot(wirie0507_try, aes(X, Y))+
  geom_path(aes(color=ID_mtb))+
  geom_point(aes(color = ID_mtb))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  labs(title = "New segments based on refined criteria", subtitle = "Wiriehorn 05-07")
```

The results of the refined segmentation step capture the mountain biking pattern.

#### Valbirse

```{r valbirse speed , include=FALSE}
# calculate distance between points d_plusx for distance
# calculate time between points
# calculate speed
# calculate average speed between four fixes

valbirse_speed <- valbirse_transport |> 
  mutate(
    d_plus1 = sqrt((lead(X)-X)^2 + (lead(Y)-Y)^2),
    d_plus2 = sqrt((lead(X,2)-X)^2 + (lead(Y,2)-Y)^2), # new offset of 2 in function lead()
    d_minus1 = sqrt((lag(X)-X)^2 + (lag(Y)-Y)^2),
    d_minus2 = sqrt((lag(X,2)-X)^2 + (lag(Y,2)-Y)^2),
    t_plus1 = difftime(lead(datetime), datetime),
    t_plus2 = difftime(lead(datetime, 2), datetime),
    t_minus1 = difftime(lag(datetime), datetime),
    t_minus2 = difftime(lag(datetime, 2), datetime),
    s_plus1 = d_plus1/as.numeric(t_plus1), # s for speed [m/s]
    s_plus2 = d_plus2/as.numeric(t_plus2),
    s_minus1 = d_minus1/-as.numeric(t_minus1),
    s_minus2 = d_minus2/-as.numeric(t_minus2)
  )

# calculate mean speed within window of two neighboring points. not exactly a temporal window because the sampling time varies slightly. mean in m/s and km/h.

valbirse_speed <- valbirse_speed |>
  rowwise() |>  # so the mean per row is computed
  mutate(
    speedmean_ms = mean(c(s_plus1, s_plus2, s_minus1, s_minus2), na.rm=TRUE)
  ) |> 
  ungroup() |> # otherwise each row would represent a group, we don't want that.
  # now  we calculated the mean speed in m/s.
  # calculate mean speed in km per hour. 1 m/s = 3.6 km/h
  mutate(speedmean_kmh = speedmean_ms * 3.6)
```

```{r valbirse visualisation of average speed, dealing with NaN, include=FALSE}
# explore what we just did
ggplot(valbirse_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1)+
  geom_vline(xintercept = mean(valbirse_speed$speedmean_ms, na.rm=TRUE)) # why is there no vline?

range(valbirse_speed$speedmean_ms, na.rm=TRUE)

valbirse_speed$speedmean_ms[1:50] # how did i get inf and NaN values? something divided by 0 returns inf. 0/0 returns NaN. no vline because of nan values
pt <- is.finite(valbirse_speed$speedmean_ms) # returns TRUE if it is not one of the values NA, NaN, Inf or -Inf
length(pt[pt == FALSE]) # counts NA, NaN, Inf and -Inf. we have 125 of those

# plot points with inf and non numeric value. let's see which points are affected.

inf_filter <- valbirse_speed |> 
  filter(!is.finite(speedmean_ms))

tm_shape(valbirse_speed)+
  tm_dots()+
  tm_shape(inf_filter)+
  tm_dots("transport_mode")

# of 1.174 rows only 30 rows are affected (2,56 %). since the +-Inf, NaN and NA values emerge where either the distance or the time between two points is 0, the points in question seem to be static (either temporally or locally). where no speed can be computed, no evaluation regarding a threshold can be taken. 
# the inf/NaN/NA points are located where little movement is plausible (at the bottom and the top of the cable car allmiried). 

# new dataset to create segmentation
valbirse_segments <- valbirse_speed |> 
    mutate(static = !is.finite(valbirse_speed$speedmean_ms)) # returns TRUE for static points

# "clean" dataset for visualisation of moving point parameter profile
valbirse_speed <- valbirse_speed |>
  filter(is.finite(speedmean_ms))

ggplot(valbirse_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(valbirse_speed$speedmean_ms), col = "#a6611a") # vline is visible, average speed on that day was around 10 m/s

ggplot(valbirse_speed, aes(speedmean_kmh))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(valbirse_speed$speedmean_kmh), col = "#a6611a") # vline is visible, average speed on that day was around 24.01725 km/h

mean(valbirse_speed$speedmean_kmh)
```

```{r valbirse segment and visualize, include=FALSE}
valbirse_segments <- valbirse_segments |> 
  mutate(ID=rle_id(static))

valbirse_segments <- valbirse_segments |> 
  filter(!static) # select rows where the static value is not TRUE to select the moving segments

ggplot(valbirse_segments, aes(X, Y))+
  geom_path(aes(color=ID))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# tm_shape(valbirse_segments)+
#   tm_dots("ID")+
#   tmap_options(max.categories = 37)

# MP profile
ggplot(valbirse_segments, aes(x = datetime, y = speedmean_kmh))+
  geom_line(aes(color = ID))+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile of average speed", subtitle = "moving segments of Valbirse 05-07")

# cable car not excluded
```

```{r valbirse setting speed range, include=FALSE}
valbirse_speed$transport_mode[valbirse_speed$speedmean_kmh <= 26.95490 & !(valbirse_speed$speedmean_kmh >= 2.855 & valbirse_speed$speedmean_kmh <= 10.308)] <- "mtb"

# tm_shape(valbirse_speed)+
#   tm_dots("transport_mode")

valbirse_segments$transport_mode[valbirse_segments$speedmean_kmh <= 26.95490 & !(valbirse_segments$speedmean_kmh >= 2.855 & valbirse_segments$speedmean_kmh <= 10.308)] <- "mtb"

valbirse_segments <- valbirse_segments |> 
  mutate(mtb_speed = transport_mode =="mtb")

length(valbirse_segments$mtb_speed[valbirse_segments$mtb_speed == TRUE]) # 248 true

# tm_shape(valbirse_segments)+
#   tm_dots("transport_mode")
```

```{r valbirse groundcover, include=FALSE}

valbirse_gc <- st_intersection(valbirse_segments, bodenbedeckung)

head(valbirse_gc)
# display values occurring on the trajectory.
unique(valbirse_gc$groundcover)

# tm_shape(valbirse_gc)+
#   tm_dots("groundcover")
  
# ggplot(valbirse_gc, aes(x=datetime, y=speedmean_kmh))+
#   geom_line()+
#   geom_point(aes(col=groundcover), alpha= .5)

valbirse_gc <- valbirse_gc |>
  mutate(mtb_gc = groundcover %in% mountainbike) # mountainbike ground cover TRUE/FALSE vector
```

```{r valbirse downward movement, include=FALSE}
valbirse_alti <- valbirse_gc |> 
  mutate(hoehe = terra::extract(alti, valbirse_gc)) # extract values froam a Raster for a set of locations.

# posmo_annotated <- na.omit(posmo_annotated)

valbirse_alti <- valbirse_alti[order(valbirse_alti$datetime, decreasing = FALSE),]

ggplot(data= valbirse_alti, aes(datetime, hoehe$altivrt))+
  geom_point(aes(color = groundcover))+
  geom_path()+
  labs(title = "Height change over time and ground cover of trajectory", subtitle = "Valbirse 05-07")+
  ylab("altitude [m.a.s.l.]")+
  xlab("time")

valbirse_alti <- valbirse_alti|> 
  mutate(h_plus4 = (lead(hoehe$altivrt, 4)- hoehe$altivrt))

## uphill or downhill

## where sum is smaller than 0 we have a descent
valbirse_alti <- valbirse_alti |> 
  mutate(mtb_elevation = h_plus4 < 0)

# tm_shape(valbirse_alti)+
#   tm_dots("mtb_elevation")

valbirse_alti <- na.omit(valbirse_alti)
```

```{r valbirse combination of criteria, quantification, include=FALSE}

valbirse <- valbirse_alti |> 
  select(datetime, ID, mtb_speed, mtb_gc, mtb_elevation, X, Y, geometry) |> 
  rowwise() |> 
  mutate(mtb = sum(mtb_speed, mtb_gc, mtb_elevation, na.rm=TRUE)) |> 
  ungroup()

head(valbirse)


tm_shape(valbirse)+
  tm_dots("mtb", palette= brewer.pal(4, "BrBG"))

length(valbirse$mtb_speed[valbirse$mtb_speed == TRUE]) # 184 true (of 1015 rows)
length(valbirse$mtb_gc[valbirse$mtb_gc == TRUE]) # 329 true
length(valbirse$mtb_elevation[valbirse$mtb_elevation == TRUE]) # 311 true


valbirse <- valbirse |> 
  mutate(mtb_count3 = mtb == 3)

length(valbirse$mtb_count3[valbirse$mtb_count3 == TRUE]) # 65 true

valbirse_summary <- valbirse |> 
  select(ID, mtb) |> 
  group_by(ID) |> 
  summarise(n_1 = sum(mtb==3),
            n_2 = sum(mtb==2),
            n_3 = sum(mtb==1)
            # sumcriteria = sum(mtb),
            # tourtime=difftime(last(datetime), first(datetime))
            )
```

On the Valbirse trajectory many points that are not part of the biking pattern fit more than one criteria. 

**Valbirse. Number of matched criteria for mountain biking (mtb) for each point.**
```{r valbirse all criteria, echo=FALSE}
tm_shape(valbirse)+
  tm_dots("mtb", palette= brewer.pal(4, "BrBG"))
```

Taking a closer look, parts of the cable car did not match the criteria of downward movement (mtb_elevation).

**Valbirse. Speed (mtb_speed), groundcover (mtb_gc), downwards movement (mtb_elevation)**
```{r valbirse facets of every criteria, echo=FALSE}
tm_shape(valbirse)+
  tm_dots(col = c("mtb_speed", "mtb_gc", "mtb_elevation"), palette=c('#a6611a', '#80cdc1'))+
  tm_facets(sync = TRUE, ncol = 3)+
  tm_view(set.view = c(7.27159, 47.23389, 14))
```

```{r valbirse new segmentation, include=FALSE}
valbirse_try <- valbirse |> 
  mutate(
    min3 = lead(mtb_count3) == TRUE |lead(mtb_count3,2)==TRUE |lead(mtb_count3,3) == TRUE | lag(mtb_count3) == TRUE | lag(mtb_count3,2)==TRUE | lag(mtb_count3,3)==TRUE
  ) # innerhalb einer minute muss mindestens einmal der Wert drei vorkommen - also drei kriterien erfüllt sein. 

tm_shape(valbirse_try)+
  tm_dots("min3")

valbirse_try <- valbirse_try |>
  mutate(
    c_plus1 = lead(mtb),
    c_plus2 = lead(mtb,2), # new offset of 2 in function lead()
    c_minus1 = lag(mtb),
    c_minus2 = lag(mtb,2)
  ) # berechnen, wie viele kriterien bei den benachbarten punkten zutreffen und so versuchen, die punkte wo weniger kriterien zutreffen, aussschliessen. ausreichend bike punkte eingeschlossen, die nicht alle kriterien erfüllen

valbirse_try <- valbirse_try |> 
  rowwise() |> 
  mutate(c_sum = sum(c(c_plus1, c_plus2, c_minus1, c_minus2))) |> 
  ungroup()

valbirse_try <- valbirse_try |> 
  mutate(mtb_sum = c_sum >= 6) |> 
  mutate(mtb_refined = mtb_sum == TRUE & min3 == TRUE)

# tm_shape(valbirse_try)+
#   tm_dots("mtb_sum")
# 
# tm_shape(valbirse_try)+
#   tm_dots("mtb_refined")

valbirse_try <- valbirse_try |> 
  mutate(ID_mtb=rle_id(mtb_refined))

valbirse_try <- na.omit(valbirse_try)
```


**Valbirse trajectory. The points matching the refined criteria return TRUE.**
```{r valbirse basis for new segmentation, echo=FALSE}
tm_shape(valbirse_try)+
  tm_dots("mtb_refined", palette=c('#a6611a', '#80cdc1'))+
  tm_view(set.view = c(7.27159, 47.23389, 14))
```


```{r valbirse new segmentation and visualisation, echo=FALSE}
valbirse_try <- valbirse_try |>
  filter(mtb_refined==TRUE) # select rows where the criteria for the last segmentation are considered TRUE to select the moving segments

ggplot(valbirse_try, aes(X, Y))+
  geom_path(aes(color=ID_mtb))+
  geom_point(aes(color = ID_mtb))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  labs(title = "New segments based on refined criteria", subtitle = "Valbirse")

```

**New Segments based on refined criteria for Valbirse, interactive map for closer inspection.**
```{r valbirse interactive new mtb segments, echo=FALSE}
tm_shape(valbirse_try)+
  tm_dots("ID_mtb")+
  tm_view(set.view = c(7.30973, 47.15863, 11))
  
# something does not work with the ID_mtb display. the legend shows too many classes
  # +
  #  tmap_options(max.categories = 12)
```

After the refined criteria were applied, two segments covering five points in Biel/Bienne were considered part of the mountainbike movement pattern. Most of the isolated biking segments are located in rural areas close to Malleray, where mountain biking seems more likely.

The detection of the downhill movement pattern based on speed, groundcover and downward motion was successful for Wiriehorn 05-18 and Wiriehorn 05-07. For the Valbirse trajectory, it is possible that mountain biking segments have been isolated where no mountain biking has taken place.


## Discussion

The criteria of speed, ground cover and downward motion could be shown useful for detecting and characterizing downhill mountain biking. The visualisations revealed points where mountain biking is plausible. For two out of three trajectories the criteria and the method applied worked well. Combination of the three criteria could also be used for segmentation, therefore allowing extraction or annotation of mountain biking segments within a trajectory. However, there are some issues to consider.

The two trajectories where detection was successful were recorded in the same location, and given this similarity it is no surprise the criteria matched quite well. Here, I only validated the data visually and in a qualitative manner. In the context of movement pattern detection, assessing the internal validity or the sensitivity of the method to parameters changes are relevant (Laube, 2014). Such steps would require additional datasets, which I lacked due to the choice of limiting the ground cover information to the spatial extent of one Swiss Region. By using other ground cover datasets, trajectories with different spatial extents could have been analysed.

Furthermore, the choice of the parameters took place in an explorative way, mainly to exclude unwanted features (e.g. set the speed range to exclude the cable car). Thus, the Parameter values may work well for the trajectories I experimented with, but might be to narrow (or wide) to fit other mountain biking trajectories. Some parameters, especially speed, vary with the (temporal) scale in which they are analysed (Laube & Purves, 2011). Such notions need to be examined further when validating the parameters. Other movement parameters like sinuosity and turning angle could be additional criteria to consider. In the trajectories examined here, downhill mountain biking often displayed sinuous properties. In terms of track annotation (Dodge et al., 2013), known biking trail networks could be annotated and added as criterion. 

In summary, the criteria of speed, ground cover, and downward motion successfully identified and described downhill mountain biking in most instances. However, to ensure wider applicability across various mountain biking scenarios, further validation, parameter adjustments, and consideration of additional criteria are required.

## References

Amt für Geoinformation des Kantons Bern. (2023). *Amtliche Vermessung vereinfacht* [Map].  2023https://www.agi.dij.be.ch/de/start/geoportal/geodaten/detail.html?type=geoproduct&code=MOPUBE

Bundesamt für Landestopografie swisstopo. (2022). *swissALTI3D: das hochaufgelöste Terrainmodell der Schweiz* [Map]. https://www.swisstopo.admin.ch/de/geodata/height/alti3d.html

Dodge, S., Weibel, R., & Forootan, E. (2009). Revealing the physics of movement: Com-
paring the similarity of movement characteristics of different types of moving objects.
*Computers, Environment and Urban Systems, 33*(6), 419–434. https://doi.org/10.1016/j.compenvurbsys.2009.07.008

Dodge, S., Bohrer, G., Weinzierl, R., Davidson, S. C., Kays, R., Douglas, D., Cruz, S., Han, J., Brandes, D. & Wikelski, M. (2013). The environmental-data automated track annotation (Env-DATA) system: linking animal tracks with environmental data. *Movement Ecology, 1*(3). https://doi.org/10.1186/2051-3933-1-3

Fischer, A., Lamprecht, M., & Bürgi, R. (2021). *Mountainbiken in der
Schweiz 2020: Auswertung Mountainbikeland-Befragung 2019
und Sekundäranalyse von «Sport Schweiz 2020»*. Bundesamt für Strassen ASTRA und Stiftung
SchweizMobil. https://www.astra.admin.ch/astra/de/home/themen/langsamverkehr/materialien.html

Genossenschaft Posmo Schweiz. (2022). *Posmo Project App - Tracking für Gruppen*. https://posmo.coop/produkte/posmo-project-tracking-fuer-gruppen

*How Fast Do Professional Mountain Bikers Rip Down Hills?* (April 20, 2022). https://cyclebaron.com/how-fast-do-professional-mountain-biker-rip-down-hills/

Jeremy [missing surname]. (2023). *Average Mountain Bike Speed (with 13 examples)*. The Bike report. https://www.mountainbikereport.com/mountain-bike-speed/

Laube, P. (2014). *Computational Movement Analysis*. Springer Cham. <https://doi.org/10.1007/978-3-319-10268-9>

Laube, P. & Purves, R.(2011) How fast is a cow? Cross-scale Analysis of Movement Data, *Transactions in GIS, 15*(3), 401–418, John Wiley & Sons Ltd, DOI:
10.1111/j.1467-9671.2011.01256.x

Pröbstl-Haider, U., Lund-Durlacher, D., Antonschmidt, H. & Hödl, C. (2018). Mountain bike tourism in Austria and the Alpine region – towards a sustainable model for multi-stakeholder product development. *Journal of Sustainable Tourism, 26*(4), 567-582. https://doi.org/10.1080/09669582.2017.1361428

Zajc, P. & Berzelak, N. (2016). Riding styles and characteristics of rides among Slovenian mountain bikers and management challenges. *Journal of Outdoor Recreation and Tourism, 15*, 10-19. https://doi.org/10.1016/j.jort.2016.04.009
