---
title: "script2"
author: "AureliaMo"
date: "`r Sys.Date()`"
output: html_document
---

### Libraries

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# install.packages("rgdal")

library(readr) # to import tabular data (e.g. csv)
library(dplyr) # to manipulate (tabular) data
library(tidyr)
library(ggplot2) # to visualize data
library(sf) # to handle spatial vector data
library(terra) # To handle raster data
library(lubridate) # To handle dates and times
# library(SimilarityMeasures)
library(RColorBrewer)
library(tmap)
# library(rgdal)
# library(raster)

# Color Brewer BrBG palette: #a6611a, #dfc27d, #80cdc1, #018571
# Set ggplot theme
theme_set(theme_light())

# set tmap to interactive viewing
tmap_mode("view")
```

### Data and first viusalisations

Lisa's first dataset (Wiriehorn tour)
```{r}
posmo <- read_csv("data/posmo_2023-05-18T00_00_00+02_00-2023-05-18T23_59_59+02_00.csv")

posmo <- st_as_sf(posmo, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

head(posmo)

posmo_coordinates <- st_coordinates(posmo)
posmo <- cbind(posmo, posmo_coordinates)

head(posmo) # there is an outlier. one point was recorded the night before the tour started.
# remove outlier
posmo <- posmo |> 
  slice(-1)

posmo_transport <- select(posmo, -c("weekday", "place_name", "user_id"))
posmo <- select(posmo, -c("weekday", "place_name", "transport_mode", "user_id"))
```

take a look at the other datasets, choose datasets for verification

wiriehorn
```{r}
wiriehorn <- read_csv("data/posmo/mtb_wiriehorn.csv")
head(wiriehorn)
wiriehorn <- st_as_sf(wiriehorn, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

wiriehorn_coordinates <- st_coordinates(wiriehorn)

wiriehorn <- cbind(wiriehorn, wiriehorn_coordinates)
head(wiriehorn)

# again there is an outlier
wiriehorn <- wiriehorn |> 
  slice(-1)

wiriehorn_transport <- select(wiriehorn, -c("weekday", "place_name", "user_id"))

tm_shape(wiriehorn_transport)+
  tm_dots("transport_mode")+
  tm_layout(title= 'Wiriehorn trajectory of the 6th of May', title.position = c('right', 'top'))

# here we see that some parts of the trajectory were labelled as bike
```

valbirse
```{r}
valbirse <- read_csv("data/posmo/mtb_valbirse.csv")
head(valbirse)
valbirse <- st_as_sf(valbirse, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

valbirse_coordinates <- st_coordinates(valbirse)

valbirse <- cbind(valbirse, valbirse_coordinates)
head(valbirse)

# again there is an outlier
valbirse <- valbirse |> 
  slice(-1)

valbirse_transport <- select(valbirse, -c("weekday", "place_name", "user_id"))

tm_shape(valbirse_transport)+
  tm_dots("transport_mode")

ggplot(valbirse, aes(x=X, y=Y))+
  geom_path(aes(col=datetime))+
  coord_fixed()
```

solothurn
```{r}
solothurn <- read_csv("data/posmo/mtb_solothurn.csv")
head(solothurn)
solothurn <- st_as_sf(solothurn, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

solothurn_coordinates <- st_coordinates(solothurn)

solothurn <- cbind(solothurn, solothurn_coordinates)
head(solothurn)

solothurn_transport <- select(solothurn, -c("weekday", "place_name", "user_id"))

tm_shape(solothurn_transport)+
  tm_dots("transport_mode")
```

miniride

```{r}
miniride <- read_csv("data/posmo/mtb_miniride.csv")
head(miniride)
miniride <- st_as_sf(miniride, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

miniride_coordinates <- st_coordinates(miniride)
miniride <- cbind(miniride, miniride_coordinates)
head(miniride)

# again there is an outlier
miniride <- miniride |> 
  slice(-1)

miniride_transport <- select(miniride, -c("weekday", "place_name", "user_id"))

tm_shape(miniride_transport)+
  tm_dots("transport_mode")
```

I decided to use those three datasets: Valbirse, Wiriehorn, and posmo (also from Wiriehorn). In order to do some preprocessing in ArcGIS i export the files to shapefiles. in ArcGIS, i try to clip the ground cover Dataset MOPUBE to the relevant buffered area surrounding the trajectory. It's faster to load MOPUBE into ArcGIS.
```{r}
# st_write(valbirse, "data/shapefiles/valbirse.shp")
# st_write(wiriehorn, "data/shapefiles/wiriehorn.shp")
# st_write(posmo, "data/shapefiles/posmo.shp")
```

```{r}
tm_shape(posmo_transport)+
  tm_dots("transport_mode")+
  tm_layout(title= 'Wiriehorn trajectory of the 18th of May', title.position = c('right', 'top'))
```

most of the trajectories is labelled with the transport mode "car" and other. The
loop located in the south of the Wiriehorn trajectory shows the part where Lisa
went downhill-biking in Diemtigtal, Allmiried. Most of that section is
labelled as "car", wherease some points are labelled as "walk". We now
want to try to find out some criteria in order to be able to isolate
that downhill biking part and label it as "downhill biking"

## Isolation of mountainbiking pattern

### Criteria I: speed

Speed threshold compute movement parameter speed for every fix and a
profile of the movement parameter. (Dodge et al., 2009)

```{r}
# calculate distance between points d_plusx for distance
# calculate time between points
# calculate speed
# calculate average speed between four fixes

wirie0518_speed <- posmo_transport |> 
  mutate(
    d_plus1 = sqrt((lead(X)-X)^2 + (lead(Y)-Y)^2),
    d_plus2 = sqrt((lead(X,2)-X)^2 + (lead(Y,2)-Y)^2), # new offset of 2 in function lead()
    d_minus1 = sqrt((lag(X)-X)^2 + (lag(Y)-Y)^2),
    d_minus2 = sqrt((lag(X,2)-X)^2 + (lag(Y,2)-Y)^2),
    t_plus1 = difftime(lead(datetime), datetime),
    t_plus2 = difftime(lead(datetime, 2), datetime),
    t_minus1 = difftime(lag(datetime), datetime),
    t_minus2 = difftime(lag(datetime, 2), datetime),
    s_plus1 = d_plus1/as.numeric(t_plus1), # s for speed [m/s]
    s_plus2 = d_plus2/as.numeric(t_plus2),
    s_minus1 = d_minus1/-as.numeric(t_minus1),
    s_minus2 = d_minus2/-as.numeric(t_minus2)
  )

# calculate mean speed within window of two neighboring points. not exactly a temporal window because the sampling time varies slightly. mean in m/s and km/h.

wirie0518_speed <- wirie0518_speed |>
  rowwise() |>  # so the mean per row is computed
  mutate(
    speedmean_ms = mean(c(s_plus1, s_plus2, s_minus1, s_minus2), na.rm=TRUE)
  ) |> 
  ungroup() |> # otherwise each row would represent a group, we don't want that.
  # now  we calculated the mean speed in m/s.
  # calculate mean speed in km per hour. 1 m/s = 3.6 km/h
  mutate(speedmean_kmh = speedmean_ms * 3.6)


```


#### visualisation of average speed, dealing with NaN

```{r}

#### visualisation of average speed, dealing with NaN

# explore what we just did
ggplot(wirie0518_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1)+
  geom_vline(xintercept = mean(wirie0518_speed$speedmean_ms, na.rm=TRUE)) # why is there no vline?

range(wirie0518_speed$speedmean_ms, na.rm=TRUE)

wirie0518_speed$speedmean_ms[1:50] # how did i get inf and NaN values? something divided by 0 returns inf. 0/0 returns NaN. no vline because of nan values
pt <- is.finite(wirie0518_speed$speedmean_ms) # returns TRUE if it is not one of the values NA, NaN, Inf or -Inf
length(pt[pt == FALSE]) # counts NA, NaN, Inf and -Inf. we have 80 of those

# plot points with inf and non numeric value. let's see which points are affected.

inf_filter <- wirie0518_speed |> 
  filter(!is.finite(speedmean_ms))

tm_shape(wirie0518_speed)+
  tm_dots()+
  tm_shape(inf_filter)+
  tm_dots("transport_mode")

# of 2,237 rows only 80 rows are affected (3.58 %). since the +-Inf, NaN and NA values emerge where either the distance or the time between two points is 0, the points in question seem to be static (either temporally or locally). where no speed can be computed, no evaluation regarding a threshold can be taken. 
# the inf/NaN/NA points are located where little movement is plausible (at the bottom and the top of the cable car allmiried, somewhere in the middle of the downhill trail, at train stations in Solothurn). 

# new dataset to create segmentation
wirie0518_segments <- wirie0518_speed |> 
    mutate(static = !is.finite(wirie0518_speed$speedmean_ms)) # returns TRUE for static points

# "clean" dataset for visualisation of moving point parameter profile
wirie0518_speed <- wirie0518_speed |>
  filter(is.finite(speedmean_ms))

ggplot(wirie0518_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(wirie0518_speed$speedmean_ms), col = "#a6611a") # vline is visible, average speed on that day was around 10 m/s

ggplot(wirie0518_speed, aes(speedmean_kmh))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(wirie0518_speed$speedmean_kmh), col = "#a6611a") # vline is visible, average speed on that day was around 37.33548 km/h

mean(wirie0518_speed$speedmean_kmh)

```


#### moving parameter (MP) profile, visualisation of static points 
for speed (Dodge et al., 2009)

```{r}
#### moving parameter (MP) profile, visualisation of static points 
# for speed (Dodge et al., 2009)

ggplot(wirie0518_speed, aes(x = datetime, y = speedmean_kmh))+
  geom_path(col = "#a6611a" )+
  geom_point(col ="#dfc27d", alpha = .2)+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile for average speed", subtitle = "Wiriehorn tour 05-18")

```

**Looking at the plot above, we can see, that the mountainbiking pattern
must have been taking place between 9 am and about 1.30 pm. Therefore we
will look a bit closer at the exact speed during this time**. to set a reasonable
speed range or threshold, i want to figure out the average speed of a
bike descent. i try to isolate the bike segments.

static points visualisation
where are the static points in the allmiried area? i see static points at the talstation, bergstation and halfway on the trail. (breaks to wait for each other, slow movements waiting for the funiculare)
```{r}
# # static points visualisation
# where are the static points in the allmiried area? i see static points at the talstation, bergstation and halfway on the trail. (breaks to wait for each other, slow movements waiting for the funiculare)
tm_shape(wirie0518_segments)+
  tm_dots("static")
```

#### segmentation
assign unique IDs to the segments

```{r}
#### Segmentation
# function for assigning unique ID to the subtrajectories

rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

wirie0518_segments <- wirie0518_segments |> 
  mutate(ID=rle_id(static))
```

Visualize the moving segments by colourizing them by segment_ID.

```{r}
# Visualize the moving segments by colourizing them by segment_ID.

wirie0518_segments <- wirie0518_segments |> 
  filter(!static) # select rows where the static value is not TRUE to select the moving segments

ggplot(wirie0518_segments, aes(X, Y))+
  geom_path(aes(color=ID))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# tm_shape(wirie0518_segments)+
#   tm_dots("ID")+
#   tmap_options(max.categories = 37)

# MP profile
ggplot(wirie0518_segments, aes(x = datetime, y = speedmean_kmh))+
  geom_line(aes(color = ID))+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile of average speed", subtitle = "moving segments of Wiriehorn 05-18")


```


#### choosing segments and defining range
looks like the segments 12, 14, 16, 18, 20, 22, 24, 26 are mountainbiking segments
selecting the segments between 9:00 and 13:00

```{r, choosing segments and defining range}

# looks like the segments 12, 14, 16, 18, 20, 22, 24, 26 are mountainbiking segments
wirie0518_threshold <- wirie0518_segments |> 
  filter(ID == c(12, 14, 16, 18, 20, 22, 24, 26))

ggplot(wirie0518_threshold, aes(X, Y))+
  geom_point(aes(color=ID))+
  geom_path(aes(color=ID))+
  coord_fixed()

ggplot(wirie0518_threshold, aes(x = datetime, y = speedmean_kmh))+
  geom_path(color="#a6611a")+
  geom_point(col ="#dfc27d", alpha = .6)+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile for average speed", subtitle = "mountainbike segments Wiriehorn tour 05-18")
# covers the time range between 08:42 - 13:13 which corresponds to biking
# figure out which speed range makes sense to define mountainbiking

ggplot(wirie0518_threshold, aes(y=speedmean_kmh))+
  geom_boxplot(color="#a6611a", fill="#dfc27d", alpha=0.2)+
  ylab("mean speed [kmh]")+
  scale_x_discrete(labels = NULL, breaks = NULL)+
  labs(title = "Average speed distribution of mountainbiking segments", subtitle = "Wiriehorn 05-18")

summary(wirie0518_threshold$speedmean_kmh)
summary(wirie0518_threshold$speedmean_ms)
sd(wirie0518_threshold$speedmean_kmh)
```
speed summary for kmh
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
 0.08902  2.85510  8.26566  7.80428 10.30834 26.95490 

speed summary for ms
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.02473 0.79308 2.29602 2.16786 2.86343 7.48747 

according to the speed statistics i will choose the range of the 1st and 3rd quartile kmh (2.855 to 10.308) as the speed defining mountainbiking.

rename / overwrite rows of points within the speed range of mountainbiking.

```{r rename / overwrite rows of points within the speed range of mountainbiking}

# wirie0518_speed$transport_mode[wirie0518_speed$speedmean_kmh >= 2.855 & wirie0518_speed$speedmean_kmh <= 10.308] <- "mtb"
# 
# tm_shape(wirie0518_speed)+
#   tm_dots("transport_mode")

# zooming into the allmiried area we can see that the cable car is labelled as mtb. the speed range therefore applies mainly to the cable car. let's see if by adjusting the range to include lower values as the set threshold changes anything.

# wirie0518_speed$transport_mode[wirie0518_speed$speedmean_kmh <= 10.308] <- "mtb"
# 
# tm_shape(wirie0518_speed)+
#   tm_dots("transport_mode")

# a few more points are included, a great deal of the downhill parts are still not covered though. adjust upper threshold, choose max value of statistics output above. exclude range of cable car

wirie0518_speed$transport_mode[wirie0518_speed$speedmean_kmh <= 26.95490 & !(wirie0518_speed$speedmean_kmh >= 2.855 & wirie0518_speed$speedmean_kmh <= 10.308)] <- "mtb"

tm_shape(wirie0518_speed)+
  tm_dots("transport_mode")

# zooming in the map, we see that the cable car is excluded in the allmiried area. since the walking speed of 4-5kmh is also excluded, the transport mode "walking" is preserved. however, some points on the mountainbike descent are excluded, probably because they fall in the speed range of the cable car. otherwise, the result represents most of the downhill mountainbiking.

wirie0518_segments$transport_mode[wirie0518_segments$speedmean_kmh <= 26.95490 & !(wirie0518_segments$speedmean_kmh >= 2.855 & wirie0518_segments$speedmean_kmh <= 10.308)] <- "mtb"



```
choosing the average speeds including the full range of the mountainbiking speeds did not exclude the cable car. taking a closer look a the moving parameter profile of the mountainbike segments we see that the cable car travels probably at an average of 8kmh. since average walking speed.

speed threshold might be adjusted according to the speed of the cable car on every mountain of the tour.

try it on moving segments
```{r, try it on moving segments}
wirie0518_segments$transport_mode[wirie0518_segments$speedmean_kmh <= 26.95490 & !(wirie0518_segments$speedmean_kmh >= 2.855 & wirie0518_segments$speedmean_kmh <= 10.308)] <- "mtb"

wirie0518_segments <- wirie0518_segments |> 
  mutate(mtb_speed = transport_mode =="mtb")

length(wirie0518_segments$mtb_speed[wirie0518_segments$mtb_speed == TRUE]) # 605 true

tm_shape(wirie0518_segments)+
  tm_dots("mtb_speed")+
  tm_view(set.view = c(7.54170, 46.60981, 14))
```


#### assigning transport mode mtb

```{r, assigning transport mode mtb}
# wirie0518_speed <- wirie0518_speed |> 
#   mutate(mtb_speed = transport_mode =="mtb")
# 
# length(wirie0518_speed$mtb_speed[wirie0518_speed$mtb_speed == TRUE]) # 605 true
# 
# tm_shape(wirie0518_speed)+
#   tm_dots("mtb_speed")

```


### Criteria II: Ground cover

#### read ground cover data
in a next step, we will try to find other criteria by using the MOPUBE ground cover dataset.

```{r read ground cover data}
bodenbedeckung <- read_sf("data/shapefiles/MOPUBE_traj.shp")
head(bodenbedeckung)

# remove columns that are not required

bodenbedeckung <- bodenbedeckung |> 
  transmute(BBFID = BBFID,
            groundcover = BBARTT_BEZ,
            geometry = geometry)

tm_shape(bodenbedeckung)+
  tm_polygons("groundcover")+
  tmap_options(check.and.fix = TRUE)

# in total, we have 22 ground cover types. since we assume that mountainbiking takes place on vegetated and/or natural groundcovers, every groundcover type seems suitable except for "Abbau, Deponie", Bahn", "Gebäude", "Strasse, Weg", "Trottoir", "übrige befestigte" and "Verkehrsinsel". we could argue that water bodies are not suitable as well, but depending on their size it is not impossible to encounter such features when biking.
```

intersect the trajectory dataset (already containing the speed) with the groundcover information 
```{r}

wirie0518_gc <- st_intersection(wirie0518_segments, bodenbedeckung)

head(wirie0518_gc)
# display values occurring on the trajectory.
unique(wirie0518_gc$groundcover)

tm_shape(wirie0518_gc)+
  tm_dots("groundcover")+
  tmap_options(check.and.fix = TRUE)
  
ggplot(wirie0518_gc, aes(x=datetime, y=speedmean_kmh))+
  geom_line()+
  geom_point(aes(col=groundcover), alpha= .5)

```

```{r}
# vector with all ground cover types including natural / vegetated features.
mountainbike <- c("Acker, Wiese, Weide", "Fels", "fliessendes Gewässer", "Gartenanlage", "Geröll, Sand", "geschlossener Wald", "Schilfgürtel", "Stehendes Gewässer", "übrige bestockte", "übrige humusierte", "übrige Intensivkultur", "übrige vegetationslose", "Wasserbecken", "Wytweide dicht", "Wytweide offen")

wirie0518_gc <- wirie0518_gc |>
  mutate(mtb_gc = groundcover %in% mountainbike) # mountainbike ground cover TRUE/FALSE vector
```

however is not a unique identifyer for mountainbiking, as it
could also be hiking or other outdoor activities. We will now annotate
the groundtype data to the posmo data and then do the same with the topo
to also add height information to the data in order to achieve filtering
of mountainbiking.

```{r}
tm_shape(wirie0518_gc)+
  tm_dots("mtb_gc")
```
we can see that the groundcover criteria does not exclude the cable car that Lisa took to get to the top of the mountain.

### Criteria III: Elevation model

now i will do the same with the terrainmodel

import DEM swissALTI3D with spatial extent which covers all three trajectories.

```{r}
# csv has all download paths from alti3d tiles:  https://www.swisstopo.admin.ch/en/geodata/height/alti3d.html
# all_inc_tif <- read.csv("data/alti3D_all_inc.csv", header = FALSE)
# # 
# # # terra help https://rspatial.org/spatial-terra/8-rastermanip.html
# # 
# # download all files to an empty folder
# for (fi in all_inc_tif$V1){
# outfile <- basename(fi)
# print(outfile)
# download.file(fi, paste0("data/alti3D_all_inc/", outfile),mode = "wb") # mode (binary) very important
# }

# list takes all files with .tif from a folder
file_list <- list.files("data/alti3D_all_inc/",".tif",full.names = TRUE)

# makes a virtual raster layer from the files
vrt(file_list, "altivrt.vrt",overwrite = TRUE)

# import the data from the virtual raster layer
alti <- rast("altivrt.vrt")

# check if extent matches the trajectories
# plot(alti)
# plot(wirie0518_speed, add=TRUE)
# plot(valbirse, add=TRUE)

```

associate the height to the points on the trajectory, visualize
```{r}
wirie0518_alti <- wirie0518_gc |> 
  mutate(hoehe = terra::extract(alti, wirie0518_gc)) # extract values froam a Raster for a set of locations. becauses function "extract" is masked from the tidyr library, the terra pkg needs to be specified

wirie0518_alti <- wirie0518_alti[order(wirie0518_alti$datetime, decreasing = FALSE),]

ggplot(data= wirie0518_alti, aes(datetime, hoehe$altivrt))+
  geom_point(aes(color = groundcover))+
  geom_path()+
  labs(title = "Height change over time and ground cover of trajectory", subtitle = "Wiriehorn 05-18")+
  ylab("altitude [m.a.s.l.]")+
  xlab("time")
```

in this last visualization we can see very clearly, that the combination
of ground type and elevation will probably make for great criteria to
filter the pattern. In order to filter it from hiking, we will further
add the speed. But first, it needs to be defined that we only want
downhill movements on not paved roads for the further evaluation.

That the height difference is clearly visible, we will compute the
height difference every half minute, which equals 4 points.

```{r}
wirie0518_alti <- wirie0518_alti|> 
  mutate(
    h_plus1 = (lead(hoehe$altivrt) -hoehe$altivrt),
    h_plus2 = (lead(hoehe$altivrt, 2)- hoehe$altivrt),
    h_plus3 = (lead(hoehe$altivrt, 3)- hoehe$altivrt),
    h_plus4 = (lead(hoehe$altivrt, 4)- hoehe$altivrt)
  )

## if the next fix (within a window of 10 / 20 or 30 secs) is located at a lower altitude, the movement goes downhill. if the value of the difference between the following fix and the current fix is negative, i assume the movement goes downward.

## where sum is smaller than 0 we have a descent
wirie0518_alti <- wirie0518_alti |> 
  mutate(mtb_elevation = h_plus4 < 0)

tm_shape(wirie0518_alti)+
  tm_dots("mtb_elevation")


# TRUE means downward movement (negative elevation difference between two fixes)

# since the car ride includes movement in both directions, it shows both values vor upwards and downwards. 
```

elevation does not exclude cable car, even though the movement should be uphill.

## Combination of criteria

If the sum of the 30 seconds movement block is negative and the
groundtype is either Acker, Wiese, Weide or else geschlossener Wald oder
übrige humusierte, it must be checked with the speed to determine if
these criteria match mountainbiking.

```{r}
wirie0518 <- wirie0518_alti |> 
  select(datetime, ID, mtb_speed, mtb_gc, mtb_elevation, X, Y, geometry) |> 
  rowwise() |> 
  mutate(mtb = sum(mtb_speed, mtb_gc, mtb_elevation, na.rm=TRUE)) |> 
  ungroup()

head(wirie0518)
wirie0518 <- na.omit(wirie0518)

tm_shape(wirie0518)+
  tm_dots("mtb", palette= brewer.pal(4, "BrBG"))


# green values show how many criteria apply for the fix

length(wirie0518_alti$mtb_speed[wirie0518_alti$mtb_speed == TRUE]) # 493 true
length(wirie0518_alti$mtb_gc[wirie0518_alti$mtb_gc == TRUE]) # 874 true
length(wirie0518_alti$mtb_elevation[wirie0518_alti$mtb_elevation == TRUE]) # 807 true

wirie0518 <- wirie0518 |>
  mutate(mtb_count3 = mtb == 3)

length(wirie0518$mtb_count3[wirie0518$mtb_count3 == TRUE]) # 318 true

wirie0518_summary <- wirie0518 |> 
  select(ID, mtb) |> 
  group_by(ID) |> 
  summarise(n_1 = sum(mtb==3),
            n_2 = sum(mtb==2),
            n_3 = sum(mtb==1)
            # sumcriteria = sum(mtb),
            # tourtime=difftime(last(datetime), first(datetime))
            )

wirie0518_sumlong <- pivot_longer(wirie0518_summary, 2:4,
               names_to = "criteria",
               values_to = "points")

# ggplot(wirie0518_sumlong, aes(fill = criteria, x = ID, y = points)) +
#   geom_bar(position = "dodge", stat = "identity")+
#   scale_fill_manual(values = c("n_1" = "#dfc27d",
#                                "n_2" = "#80cdc1",
#                                "n_3" = "#018571"
#                                ))

ggplot(wirie0518_sumlong, aes(fill = criteria, x = ID, y = points)) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = c("n_1" = "#dfc27d",
                               "n_2" = "#80cdc1",
                               "n_3" = "#018571"
                               ))+
  xlab("Segment ID")+
  ylab("number of points on trajectory")+
  labs(title = "Number of criteria applying to segments", subtitle = "Wiriehorn 05-18")+
  geom_text(data=subset(wirie0518_sumlong,points > 5), aes(label = points), stat = "identity", colour = "black", position = position_stack(vjust = 0.5), size=2)

```
minimum/maximum duration of downhill tours?
exclusion criteria (in case two criteria are ok)
segments wit x percentage of 3TRUE are mountainbiking.

#### new segmentation
```{r}

wirie0518_try <- wirie0518 |> 
  mutate(
    min3 = lead(mtb_count3) == TRUE |lead(mtb_count3,2)==TRUE |lead(mtb_count3,3) == TRUE | lag(mtb_count3) == TRUE | lag(mtb_count3,2)==TRUE | lag(mtb_count3,3)==TRUE
  ) # innerhalb einer minute muss mindestens einmal der Wert drei vorkommen - also drei kriterien erfüllt sein. 

tm_shape(wirie0518_try)+
  tm_dots("min3")

wirie0518_try <- wirie0518_try |>
  mutate(
    c_plus1 = lead(mtb),
    c_plus2 = lead(mtb,2), # new offset of 2 in function lead()
    c_minus1 = lag(mtb),
    c_minus2 = lag(mtb,2)
  ) # berechnen, wie viele kriterien bei den benachbarten punkten zutreffen und so versuchen, die punkte wo weniger kriterien zutreffen, aussschliessen. ausreichend bike punkte eingeschlossen, die nicht alle kriterien erfüllen

wirie0518_try <- wirie0518_try |> 
  rowwise() |> 
  mutate(c_sum = sum(c(c_plus1, c_plus2, c_minus1, c_minus2))) |> 
  ungroup()

wirie0518_try <- wirie0518_try |> 
  mutate(mtb_sum = c_sum >= 6) |> 
  mutate(lastsegm = mtb_sum == TRUE & min3 == TRUE)

tm_shape(wirie0518_try)+
  tm_dots("mtb_sum")

# wirie0518_try <- wirie0518_try|> 
#   mutate(segm_plus_1 = as.numeric(lead(mtb_sum)),
#          segm_plus_2 = as.numeric(lead(mtb_sum, 2)),
#          segm_minus_1 = as.numeric(lag(mtb_sum)),
#          segm_minus_2 = as.numeric(lag(mtb_sum, 2)))|> 
#   rowwise() |> 
#   mutate(segm_sum = sum(c(segm_plus_1, segm_plus_2, segm_minus_1, segm_minus_2))) |> 
#   ungroup()
# 
# wirie0518_try <- wirie0518_try |> 
#   mutate(lastsegm = segm_sum >= 3) # threshold for last segmentation

tm_shape(wirie0518_try)+
  tm_dots("lastsegm")

wirie0518_try <- wirie0518_try |> 
  mutate(ID_mtb=rle_id(lastsegm))

tm_shape(wirie0518_try)+
  tm_dots("lastsegm")


# wirie0518_try <- wirie0518_try |> 
#   filter(lastsegm==TRUE) # select rows where the value is TRUE to select the moving segments
# 
# ggplot(wirie0518_try, aes(X, Y))+
#   geom_path(aes(color=ID_mtb))+
#   geom_point(aes(color = ID_mtb))+
#   coord_fixed()+
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```

#### visualise new segments

```{r}

wirie0518_trysum <- wirie0518_try |> 
  select(ID_mtb, mtb) |> 
  group_by(ID_mtb) |> 
  summarise(n_1 = sum(mtb==3),
            n_2 = sum(mtb==2),
            n_3 = sum(mtb==1)
            # sumcriteria = sum(mtb),
            # tourtime=difftime(last(datetime), first(datetime))
            )

wirie0518_trysumlong <- pivot_longer(wirie0518_trysum, 2:4,
               names_to = "criteria",
               values_to = "points")


ggplot(wirie0518_trysumlong, aes(fill = criteria, x = ID_mtb, y = points)) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = c("n_1" = "#dfc27d",
                               "n_2" = "#80cdc1",
                               "n_3" = "#018571"
                               ))+
  xlab("Segment ID")+
  ylab("number of points on trajectory")+
  labs(title = "Number of criteria applying to segments", subtitle = "Wiriehorn 05-18")+
  geom_text(data=subset(wirie0518_trysumlong,points > 5), aes(label = points), stat = "identity", colour = "black", position = position_stack(vjust = 0.5), size=2)
```


## Verification on other trajectories

### Wiriehorn 05-07 speed

Speed threshold compute movement parameter speed for every fix and a
profile of the movement parameter. (Dodge et al., 2009)

```{r}
# calculate distance between points d_plusx for distance
# calculate time between points
# calculate speed
# calculate average speed between four fixes

wirie0507_speed <- wiriehorn_transport |> 
  mutate(
    d_plus1 = sqrt((lead(X)-X)^2 + (lead(Y)-Y)^2),
    d_plus2 = sqrt((lead(X,2)-X)^2 + (lead(Y,2)-Y)^2), # new offset of 2 in function lead()
    d_minus1 = sqrt((lag(X)-X)^2 + (lag(Y)-Y)^2),
    d_minus2 = sqrt((lag(X,2)-X)^2 + (lag(Y,2)-Y)^2),
    t_plus1 = difftime(lead(datetime), datetime),
    t_plus2 = difftime(lead(datetime, 2), datetime),
    t_minus1 = difftime(lag(datetime), datetime),
    t_minus2 = difftime(lag(datetime, 2), datetime),
    s_plus1 = d_plus1/as.numeric(t_plus1), # s for speed [m/s]
    s_plus2 = d_plus2/as.numeric(t_plus2),
    s_minus1 = d_minus1/-as.numeric(t_minus1),
    s_minus2 = d_minus2/-as.numeric(t_minus2)
  )

# calculate mean speed within window of two neighboring points. not exactly a temporal window because the sampling time varies slightly. mean in m/s and km/h.

wirie0507_speed <- wirie0507_speed |>
  rowwise() |>  # so the mean per row is computed
  mutate(
    speedmean_ms = mean(c(s_plus1, s_plus2, s_minus1, s_minus2), na.rm=TRUE)
  ) |> 
  ungroup() |> 
  mutate(speedmean_kmh = speedmean_ms * 3.6) # calculate mean speed in km per hour. 1 m/s = 3.6 km/h
```


#### visualisation of average speed, dealing with NaN

```{r}
# explore what we just did
ggplot(wirie0507_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1)+
  geom_vline(xintercept = mean(wirie0507_speed$speedmean_ms, na.rm=TRUE)) # why is there no vline?

range(wirie0507_speed$speedmean_ms, na.rm=TRUE)

wirie0507_speed$speedmean_ms[1:60] 
pt <- is.finite(wirie0507_speed$speedmean_ms) # returns TRUE if it is not one of the values NA, NaN, Inf or -Inf
length(pt[pt == FALSE]) # counts NA, NaN, Inf and -Inf. we have 30 of those

# plot points with inf and non numeric value. let's see which points are affected.

inf_filter <- wirie0507_speed |> 
  filter(!is.finite(speedmean_ms))

tm_shape(wirie0507_speed)+
  tm_dots()+
  tm_shape(inf_filter)+
  tm_dots("transport_mode")

# of 1.174 rows only 30 rows are affected (2,56 %). since the +-Inf, NaN and NA values emerge where either the distance or the time between two points is 0, the points in question seem to be static (either temporally or locally). where no speed can be computed, no evaluation regarding a threshold can be taken. 
# the inf/NaN/NA points are located where little movement is plausible (at the bottom and the top of the cable car allmiried). 

# new dataset to create segmentation
wirie0507_segments <- wirie0507_speed |> 
    mutate(static = !is.finite(wirie0507_speed$speedmean_ms)) # returns TRUE for static points

# "clean" dataset for visualisation of moving point parameter profile
wirie0507_speed <- wirie0507_speed |>
  filter(is.finite(speedmean_ms))

ggplot(wirie0507_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(wirie0507_speed$speedmean_ms), col = "#a6611a") # vline is visible, average speed on that day was around 10 m/s

ggplot(wirie0507_speed, aes(speedmean_kmh))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(wirie0507_speed$speedmean_kmh), col = "#a6611a") # vline is visible, average speed on that day was around 43.68436 km/h

mean(wirie0507_speed$speedmean_kmh)
```


#### moving parameter (MP) profile, visualisation of static points 
for speed (Dodge et al., 2009)

```{r}
head(wirie0507_speed)

ggplot(wirie0507_speed, aes(x = datetime, y = speedmean_kmh))+
  geom_path(col = "#a6611a" )+
  geom_point(col ="#dfc27d", alpha = .2)+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile for average speed", subtitle = "Wiriehorn tour 05-18")

```

**Looking at the plot above, we can see, that the mountainbiking pattern
must have been taking place between 9 am and about 1.30 pm. Therefore we
will look a bit closer at the exact speed during this time**. to set a reasonable
speed range or threshold, i want to figure out the average speed of a
bike descent. i try to isolate the bike segments.

static points visualisation
where are the static points in the allmiried area? i see static points at the talstation, bergstation and halfway on the trail. (breaks to wait for each other, slow movements waiting for the funiculare)
```{r}
tm_shape(wirie0507_segments)+
  tm_dots("static")
```

#### segmentation
assign unique IDs to the segments

```{r}

wirie0507_segments <- wirie0507_segments |> 
  mutate(ID=rle_id(static))

ggplot(wirie0507_segments, aes(X, Y))+
  geom_path(aes(color=ID))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```

Visualize the moving segments by colourizing them by segment_ID.

```{r}

wirie0507_segments <- wirie0507_segments |> 
  filter(!static) # select rows where the static value is not TRUE to select the moving segments

ggplot(wirie0507_segments, aes(X, Y))+
  geom_path(aes(color=ID))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# tm_shape(wirie0507_segments)+
#   tm_dots("ID")+
#   tmap_options(max.categories = 37)

# MP profile
ggplot(wirie0507_segments, aes(x = datetime, y = speedmean_kmh))+
  geom_line(aes(color = ID))+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile of average speed", subtitle = "moving segments of Wiriehorn 05-18")

# cable car not excluded
```

#### choosing segments and defining range
looks like the segments 4, 6, 8, 10 are mountainbiking segments
selecting the segments between 8:30 and 11:30
```{r}
wirie0507_threshold <- wirie0507_segments |>
  filter(ID == c(4, 6, 8, 10))

ggplot(wirie0507_threshold, aes(X, Y))+
  geom_point(aes(color=ID))+
  geom_path(aes(color=ID))+
  coord_fixed()

# # covers the time range between 08:42 - 13:13 which corresponds to biking
# # figure out which speed range makes sense to define mountainbiking
# 
# ggplot(wirie0507_threshold, aes(y=speedmean_kmh))+
#   geom_boxplot(color="#a6611a", fill="#dfc27d", alpha=0.2)+
#   ylab("mean speed [kmh]")+
#   scale_x_discrete(labels = NULL, breaks = NULL)+
#   labs(title = "Average speed distribution of mountainbiking segments", subtitle = "Wiriehorn 05-18")
# 
# summary(wirie0507_threshold$speedmean_kmh)
# summary(wirie0507_threshold$speedmean_ms)
# sd(wirie0507_threshold$speedmean_kmh)
```


according to the speed statistics i will choose the range of the 1st and 3rd quartile kmh (2.855 to 10.308) as the speed defining mountainbiking.

rename / overwrite rows of points within the speed range of mountainbiking.
```{r}

# wirie0507_speed$transport_mode[wirie0507_speed$speedmean_kmh >= 2.855 & wirie0507_speed$speedmean_kmh <= 10.308] <- "mtb"
# 
# tm_shape(wirie0507_speed)+
#   tm_dots("transport_mode")

# zooming into the allmiried area we can see that the cable car is labelled as mtb. the speed range therefore applies mainly to the cable car. let's see if by adjusting the range to include lower values as the set threshold changes anything.

# wirie0507_speed$transport_mode[wirie0507_speed$speedmean_kmh <= 10.308] <- "mtb"
# 
# tm_shape(wirie0507_speed)+
#   tm_dots("transport_mode")

# a few more points are included, a great deal of the downhill parts are still not covered though. adjust upper threshold, choose max value of statistics output above. exclude range of cable car

wirie0507_speed$transport_mode[wirie0507_speed$speedmean_kmh <= 26.95490 & !(wirie0507_speed$speedmean_kmh >= 2.855 & wirie0507_speed$speedmean_kmh <= 10.308)] <- "mtb"

tm_shape(wirie0507_speed)+
  tm_dots("transport_mode")

# zooming in the map, we see that the cable car is excluded in the allmiried area. since the walking speed of 4-5kmh is also excluded, the transport mode "walking" is preserved. however, some points on the mountainbike descent are excluded, probably because they fall in the speed range of the cable car. otherwise, the result represents most of the downhill mountainbiking.

```
choosing the average speeds including the full range of the mountainbiking speeds did not exclude the cable car. taking a closer look a the moving parameter profile of the mountainbike segments we see that the cable car travels probably at an average of 8kmh. since average walking speed.

speed threshold might be adjusted according to the speed of the cable car on every mountain of the tour.

try it on moving segments
```{r}
wirie0507_segments$transport_mode[wirie0507_segments$speedmean_kmh <= 26.95490 & !(wirie0507_segments$speedmean_kmh >= 2.855 & wirie0507_segments$speedmean_kmh <= 10.308)] <- "mtb"

wirie0507_segments <- wirie0507_segments |> 
  mutate(mtb_speed = transport_mode =="mtb")

length(wirie0507_segments$mtb_speed[wirie0507_segments$mtb_speed == TRUE]) # 241 true

tm_shape(wirie0507_segments)+
  tm_dots("transport_mode")
```


#### assigning transport mode mtb
now i have to make it compatible with the other dataset with the ground cover. there, mountainbiking is labelled in a separate column with the criteria "yes".
```{r}
wirie0507_speed <- wirie0507_speed |> 
  mutate(mtb_speed = transport_mode =="mtb")

length(wirie0507_speed$mtb_speed[wirie0507_speed$mtb_speed == TRUE]) # 605 true

tm_shape(wirie0507_speed)+
  tm_dots("transport_mode")
```


### Criteria II: Ground cover

#### intersect

intersect the trajectory dataset (already containing the speed) with the groundcover information 
```{r}

wirie0507_gc <- st_intersection(wirie0507_segments, bodenbedeckung)

head(wirie0507_gc)
# display values occurring on the trajectory.
unique(wirie0507_gc$groundcover)

tm_shape(wirie0507_gc)+
  tm_dots("groundcover")
  
# ggplot(wirie0507_gc, aes(x=datetime, y=speedmean_kmh))+
#   geom_line()+
#   geom_point(aes(col=groundcover), alpha= .5)
```


We could now see, that the trajectory intersects with 7 different groundtypes.
The ground cover types that describe Lisa's mountainbike trajectory are 
"Acker, Wiese, Weide"
"Fels"
"(Gartenanlage)"
"Geschlossener Wald"
"übrige bestockte"
"übrige humusierte"
"fliessendes Gewässer"

however is not a unique identifyer for mountainbiking, as it
could also be hiking or other outdoor activities. We will now annotate
the groundtype data to the posmo data and then do the same with the topo
to also add height information to the data in order to achieve filtering
of mountainbiking.

```{r}
# suitable for Mountainbiking are the following groundtypes: 
# Acker, Wiese, Weide
# Fels
# (Gartenanlage)
# Geschlossener Wald
# übrige bestockte
# übrige humusierte
# fliessendes Gewässer

# mountainbike <- c("Acker, Wiese, Weide", "geschlossener Wald", "Fels", "übrige bestockte", "übrige humusierte", "fliessendes Gewässer", "Gartenanlage")

wirie0507_gc <- wirie0507_gc |>
  mutate(mtb_gc = groundcover %in% mountainbike) # mountainbike ground cover TRUE/FALSE vector
```

```{r}
tm_shape(wirie0507_gc)+
  tm_dots("mtb_gc")
```
we can see that the groundcover criteria does not exclude the cable car that Lisa took to get to the top of the mountain.

### Criteria III: Elevation model

#### add elevation values to dataset
associate the height to the points on the trajectory, visualize
```{r}
wirie0507_alti <- wirie0507_gc |> 
  mutate(hoehe = terra::extract(alti, wirie0507_gc)) # extract values froam a Raster for a set of locations.

# posmo_annotated <- na.omit(posmo_annotated)

wirie0507_alti <- wirie0507_alti[order(wirie0507_alti$datetime, decreasing = FALSE),]

ggplot(data= wirie0507_alti, aes(datetime, hoehe$altivrt))+
  geom_point(aes(color = groundcover))+
  geom_path()+
  labs(title = "Height change over time and ground cover of trajectory", subtitle = "Wiriehorn 05-18")+
  ylab("altitude [m.a.s.l.]")+
  xlab("time")
```

in this last visualization we can see very clearly, that the combination
of ground type and elevation will probably make for great criteria to
filter the pattern. In order to filter it from hiking, we will further
add the speed. But first, it needs to be defined that we only want
downhill movements on not paved roads for the further evaluation.

That the height difference is clearly visible, we will compute the
height difference every half minute, which equals 4 points.

```{r}
wirie0507_alti <- wirie0507_alti|> 
  mutate(
    h_plus1 = (lead(hoehe$altivrt) -hoehe$altivrt),
    h_plus2 = (lead(hoehe$altivrt, 2)- hoehe$altivrt),
    h_plus3 = (lead(hoehe$altivrt, 3)- hoehe$altivrt),
    h_plus4 = (lead(hoehe$altivrt, 4)- hoehe$altivrt)
  )

## uphill or downhill

## where sum is smaller than 0 we have a descent
wirie0507_alti <- wirie0507_alti |> 
  mutate(mtb_elevation = h_plus4 < 0)

# wirie0507_alti <- wirie0507_alti |> 
#   mutate(mtb_elevation = elevmean < 0)

tm_shape(wirie0507_alti)+
  tm_dots("mtb_elevation")
```

elevation does exclude cable car, even though the movement should be uphill.

## Combination of criteria

If the sum of the 30 seconds movement block is negative and the
groundtype is either Acker, Wiese, Weide or else geschlossener Wald oder
übrige humusierte, it must be checked with the speed to determine if
these criteria match mountainbiking.

```{r}
wirie0507 <- wirie0507_alti |> 
  select(ID, datetime, mtb_speed, mtb_gc, mtb_elevation, X, Y, geometry) |> 
  rowwise() |> 
  mutate(mtb = sum(mtb_speed, mtb_gc, mtb_elevation, na.rm=TRUE)) |> 
  ungroup()

head(wirie0507)

tm_shape(wirie0507)+
  tm_dots("mtb", palette= brewer.pal(4, "BrBG"))

length(wirie0507_alti$mtb_speed[wirie0507_alti$mtb_speed == TRUE]) # 234 true (of 1015 rows)
length(wirie0507_alti$mtb_gc[wirie0507_alti$mtb_gc == TRUE]) # 516 true
length(wirie0507_alti$mtb_elevation[wirie0507_alti$mtb_elevation == TRUE]) # 481 true


wirie0507 <- wirie0507 |> 
  mutate(mtb_count3 = mtb == 3)

length(wirie0507$mtb_count3[wirie0507$mtb_count3 == TRUE]) # 318 true

wirie0507_summary <- wirie0507 |> 
  select(ID, mtb) |> 
  group_by(ID) |> 
  summarise(n_1 = sum(mtb==3),
            n_2 = sum(mtb==2),
            n_3 = sum(mtb==1)
            # sumcriteria = sum(mtb),
            # tourtime=difftime(last(datetime), first(datetime))
            )

wirie0507_sumlong <- pivot_longer(wirie0507_summary, 2:4,
               names_to = "criteria",
               values_to = "points")

# ggplot(wirie0507_sumlong, aes(fill = criteria, x = ID, y = points)) +
#   geom_bar(position = "dodge", stat = "identity")+
#   scale_fill_manual(values = c("n_1" = "#dfc27d",
#                                "n_2" = "#80cdc1",
#                                "n_3" = "#018571"
#                                ))

ggplot(wirie0507_sumlong, aes(fill = criteria, x = ID, y = points)) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = c("n_1" = "#dfc27d",
                               "n_2" = "#80cdc1",
                               "n_3" = "#018571"
                               ))+
  xlab("Segment ID")+
  ylab("number of points on trajectory")+
  labs(title = "Number of criteria applying to segments", subtitle = "Wiriehorn 05-07")+
  geom_text(data=subset(wirie0507_sumlong,points > 5), aes(label = points), stat = "identity", colour = "black", position = position_stack(vjust = 0.5), size=2)

```


#### new segmentation
```{r}

wirie0507_try <- wirie0507 |> 
  mutate(
    min3 = lead(mtb_count3) == TRUE |lead(mtb_count3,2)==TRUE |lead(mtb_count3,3) == TRUE | lag(mtb_count3) == TRUE | lag(mtb_count3,2)==TRUE | lag(mtb_count3,3)==TRUE
  ) # innerhalb einer minute muss mindestens einmal der Wert drei vorkommen - also drei kriterien erfüllt sein. 

tm_shape(wirie0507_try)+
  tm_dots("min3")

wirie0507_try <- wirie0507_try |>
  mutate(
    c_plus1 = lead(mtb),
    c_plus2 = lead(mtb,2), # new offset of 2 in function lead()
    c_minus1 = lag(mtb),
    c_minus2 = lag(mtb,2)
  ) # berechnen, wie viele kriterien bei den benachbarten punkten zutreffen und so versuchen, die punkte wo weniger kriterien zutreffen, aussschliessen. ausreichend bike punkte eingeschlossen, die nicht alle kriterien erfüllen

wirie0507_try <- wirie0507_try |> 
  rowwise() |> 
  mutate(c_sum = sum(c(c_plus1, c_plus2, c_minus1, c_minus2))) |> 
  ungroup()

wirie0507_try <- wirie0507_try |> 
  mutate(mtb_sum = c_sum >= 6) |> 
  mutate(lastsegm = mtb_sum == TRUE & min3 == TRUE)

tm_shape(wirie0507_try)+
  tm_dots("mtb_sum")

tm_shape(wirie0507_try)+
  tm_dots("lastsegm")

wirie0507_try <- wirie0507_try |> 
  mutate(ID_mtb=rle_id(lastsegm))

tm_shape(wirie0507_try)+
  tm_dots("lastsegm")+
  tm_shape(wirie0507_try)+
  tm_dots("ID_mtb")

wirie0507_try <- wirie0507_try |>
  filter(lastsegm==TRUE) # select rows where the static value is not TRUE to select the moving segments

ggplot(wirie0507_try, aes(X, Y))+
  geom_path(aes(color=ID_mtb))+
  geom_point(aes(color = "lastsegm"))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```



## Verification 2

### Valbirse 05-06 speed

Speed threshold compute movement parameter speed for every fix and a
profile of the movement parameter. (Dodge et al., 2009)

```{r}
# calculate distance between points d_plusx for distance
# calculate time between points
# calculate speed
# calculate average speed between four fixes

valbirse_speed <- valbirse_transport |> 
  mutate(
    d_plus1 = sqrt((lead(X)-X)^2 + (lead(Y)-Y)^2),
    d_plus2 = sqrt((lead(X,2)-X)^2 + (lead(Y,2)-Y)^2), # new offset of 2 in function lead()
    d_minus1 = sqrt((lag(X)-X)^2 + (lag(Y)-Y)^2),
    d_minus2 = sqrt((lag(X,2)-X)^2 + (lag(Y,2)-Y)^2),
    t_plus1 = difftime(lead(datetime), datetime),
    t_plus2 = difftime(lead(datetime, 2), datetime),
    t_minus1 = difftime(lag(datetime), datetime),
    t_minus2 = difftime(lag(datetime, 2), datetime),
    s_plus1 = d_plus1/as.numeric(t_plus1), # s for speed [m/s]
    s_plus2 = d_plus2/as.numeric(t_plus2),
    s_minus1 = d_minus1/-as.numeric(t_minus1),
    s_minus2 = d_minus2/-as.numeric(t_minus2)
  )

# calculate mean speed within window of two neighboring points. not exactly a temporal window because the sampling time varies slightly. mean in m/s and km/h.

valbirse_speed <- valbirse_speed |>
  rowwise() |>  # so the mean per row is computed
  mutate(
    speedmean_ms = mean(c(s_plus1, s_plus2, s_minus1, s_minus2), na.rm=TRUE)
  ) |> 
  ungroup() |> # otherwise each row would represent a group, we don't want that.
  # now  we calculated the mean speed in m/s.
  # calculate mean speed in km per hour. 1 m/s = 3.6 km/h
  mutate(speedmean_kmh = speedmean_ms * 3.6)
```


#### visualisation of average speed, dealing with NaN

```{r}
# explore what we just did
ggplot(valbirse_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1)+
  geom_vline(xintercept = mean(valbirse_speed$speedmean_ms, na.rm=TRUE)) # why is there no vline?

range(valbirse_speed$speedmean_ms, na.rm=TRUE)

valbirse_speed$speedmean_ms[1:50] # how did i get inf and NaN values? something divided by 0 returns inf. 0/0 returns NaN. no vline because of nan values
pt <- is.finite(valbirse_speed$speedmean_ms) # returns TRUE if it is not one of the values NA, NaN, Inf or -Inf
length(pt[pt == FALSE]) # counts NA, NaN, Inf and -Inf. we have 125 of those

# plot points with inf and non numeric value. let's see which points are affected.

inf_filter <- valbirse_speed |> 
  filter(!is.finite(speedmean_ms))

tm_shape(valbirse_speed)+
  tm_dots()+
  tm_shape(inf_filter)+
  tm_dots("transport_mode")

# of 1.174 rows only 30 rows are affected (2,56 %). since the +-Inf, NaN and NA values emerge where either the distance or the time between two points is 0, the points in question seem to be static (either temporally or locally). where no speed can be computed, no evaluation regarding a threshold can be taken. 
# the inf/NaN/NA points are located where little movement is plausible (at the bottom and the top of the cable car allmiried). 

# new dataset to create segmentation
valbirse_segments <- valbirse_speed |> 
    mutate(static = !is.finite(valbirse_speed$speedmean_ms)) # returns TRUE for static points

# "clean" dataset for visualisation of moving point parameter profile
valbirse_speed <- valbirse_speed |>
  filter(is.finite(speedmean_ms))

ggplot(valbirse_speed, aes(speedmean_ms))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(valbirse_speed$speedmean_ms), col = "#a6611a") # vline is visible, average speed on that day was around 10 m/s

ggplot(valbirse_speed, aes(speedmean_kmh))+
  geom_histogram(binwidth = 1, fill ="#dfc27d")+
  geom_vline(xintercept = mean(valbirse_speed$speedmean_kmh), col = "#a6611a") # vline is visible, average speed on that day was around 24.01725 km/h

mean(valbirse_speed$speedmean_kmh)
```


#### moving parameter (MP) profile, visualisation of static points 
for speed (Dodge et al., 2009)

```{r}
head(valbirse_speed)

ggplot(valbirse_speed, aes(x = datetime, y = speedmean_kmh))+
  geom_path(col = "#a6611a" )+
  geom_point(col ="#dfc27d", alpha = .2)+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile for average speed", subtitle = "Valbirse tour 05-07")

```

**Looking at the plot above, we can see, that the mountainbiking pattern
must have been taking place between 9 am and about 1.30 pm. Therefore we
will look a bit closer at the exact speed during this time**. to set a reasonable
speed range or threshold, i want to figure out the average speed of a
bike descent. i try to isolate the bike segments.

static points visualisation
where are the static points in the allmiried area? i see static points at the talstation, bergstation and halfway on the trail. (breaks to wait for each other, slow movements waiting for the funiculare)
```{r}
tm_shape(valbirse_segments)+
  tm_dots("static")
```

#### segmentation
assign unique IDs to the segments

```{r}
valbirse_segments <- valbirse_segments |> 
  mutate(ID=rle_id(static))

```

Visualize the moving segments by colourizing them by segment_ID.

```{r}

valbirse_segments <- valbirse_segments |> 
  filter(!static) # select rows where the static value is not TRUE to select the moving segments

ggplot(valbirse_segments, aes(X, Y))+
  geom_path(aes(color=ID))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# tm_shape(valbirse_segments)+
#   tm_dots("ID")+
#   tmap_options(max.categories = 37)

# MP profile
ggplot(valbirse_segments, aes(x = datetime, y = speedmean_kmh))+
  geom_line(aes(color = ID))+
  ylab("average speed [km/h]")+
  xlab("time")+
  labs(title = "Movement parameter profile of average speed", subtitle = "moving segments of Valbirse 05-07")

# cable car not excluded
```

#### choosing segments and defining range
hard to tell which are mountainbiking segments, 14, 16, 18?
selecting the segments between 8:30 and 11:30
```{r}
valbirse_threshold <- valbirse_segments |>
  filter(ID == c(14, 16, 18))

ggplot(valbirse_threshold, aes(X, Y))+
  geom_point(aes(color=ID))+
  geom_path(aes(color=ID))+
  coord_fixed()
# 
# # covers the time range between 08:42 - 13:13 which corresponds to biking
# # figure out which speed range makes sense to define mountainbiking
# 
# ggplot(valbirse_threshold, aes(y=speedmean_kmh))+
#   geom_boxplot(color="#a6611a", fill="#dfc27d", alpha=0.2)+
#   ylab("mean speed [kmh]")+
#   scale_x_discrete(labels = NULL, breaks = NULL)+
#   labs(title = "Average speed distribution of mountainbiking segments", subtitle = "Wiriehorn 05-18")
# 
# summary(valbirse_threshold$speedmean_kmh)
# summary(valbirse_threshold$speedmean_ms)
# sd(valbirse_threshold$speedmean_kmh)
```


according to the speed statistics i will choose the range of the 1st and 3rd quartile kmh (2.855 to 10.308) as the speed defining mountainbiking.

rename / overwrite rows of points within the speed range of mountainbiking.
```{r}

# valbirse_speed$transport_mode[valbirse_speed$speedmean_kmh >= 2.855 & valbirse_speed$speedmean_kmh <= 10.308] <- "mtb"
# 
# tm_shape(valbirse_speed)+
#   tm_dots("transport_mode")

# zooming into the allmiried area we can see that the cable car is labelled as mtb. the speed range therefore applies mainly to the cable car. let's see if by adjusting the range to include lower values as the set threshold changes anything.

# valbirse_speed$transport_mode[valbirse_speed$speedmean_kmh <= 10.308] <- "mtb"
# 
# tm_shape(valbirse_speed)+
#   tm_dots("transport_mode")

# a few more points are included, a great deal of the downhill parts are still not covered though. adjust upper threshold, choose max value of statistics output above. exclude range of cable car

valbirse_speed$transport_mode[valbirse_speed$speedmean_kmh <= 26.95490 & !(valbirse_speed$speedmean_kmh >= 2.855 & valbirse_speed$speedmean_kmh <= 10.308)] <- "mtb"

tm_shape(valbirse_speed)+
  tm_dots("transport_mode")

# zooming in the map, we see that the cable car is excluded in the allmiried area. since the walking speed of 4-5kmh is also excluded, the transport mode "walking" is preserved. however, some points on the mountainbike descent are excluded, probably because they fall in the speed range of the cable car. otherwise, the result represents most of the downhill mountainbiking.

```
choosing the average speeds including the full range of the mountainbiking speeds did not exclude the cable car. taking a closer look a the moving parameter profile of the mountainbike segments we see that the cable car travels probably at an average of 8kmh. since average walking speed.

speed threshold might be adjusted according to the speed of the cable car on every mountain of the tour.

try it on moving segments
```{r}
valbirse_segments$transport_mode[valbirse_segments$speedmean_kmh <= 26.95490 & !(valbirse_segments$speedmean_kmh >= 2.855 & valbirse_segments$speedmean_kmh <= 10.308)] <- "mtb"

valbirse_segments <- valbirse_segments |> 
  mutate(mtb_speed = transport_mode =="mtb")

length(valbirse_segments$mtb_speed[valbirse_segments$mtb_speed == TRUE]) # 248 true

tm_shape(valbirse_segments)+
  tm_dots("transport_mode")
```


#### assigning transport mode mtb
now i have to make it compatible with the other dataset with the ground cover. there, mountainbiking is labelled in a separate column with the criteria "yes".
```{r}
valbirse_speed <- valbirse_speed |> 
  mutate(mtb_speed = transport_mode =="mtb")

length(valbirse_speed$mtb_speed[valbirse_speed$mtb_speed == TRUE]) # 605 true

tm_shape(valbirse_speed)+
  tm_dots("transport_mode")
```


### Criteria II: Ground cover

#### intersect

intersect the trajectory dataset (already containing the speed) with the groundcover information 
```{r}

valbirse_gc <- st_intersection(valbirse_segments, bodenbedeckung)

head(valbirse_gc)
# display values occurring on the trajectory.
unique(valbirse_gc$groundcover)

tm_shape(valbirse_gc)+
  tm_dots("groundcover")
  
# ggplot(valbirse_gc, aes(x=datetime, y=speedmean_kmh))+
#   geom_line()+
#   geom_point(aes(col=groundcover), alpha= .5)
```


We could now see, that the trajectory intersects with 7 different groundtypes.
The ground cover types that describe Lisa's mountainbike trajectory are 
"Acker, Wiese, Weide"
"Gartenanlage"
"Geschlossener Wald"
"übrige bestockte"
"übrige humusierte"
"Wytweide dicht"
"Wytweide offen"


however is not a unique identifyer for mountainbiking, as it
could also be hiking or other outdoor activities. We will now annotate
the groundtype data to the posmo data and then do the same with the topo
to also add height information to the data in order to achieve filtering
of mountainbiking.

```{r}
valbirse_gc <- valbirse_gc |>
  mutate(mtb_gc = groundcover %in% mountainbike) # mountainbike ground cover TRUE/FALSE vector
```

```{r}
tm_shape(valbirse_gc)+
  tm_dots("mtb_gc")
```
we can see that the groundcover criteria does not exclude the cable car that Lisa took to get to the top of the mountain. Also

### Criteria III: Elevation model

#### add elevation values to dataset
associate the height to the points on the trajectory, visualize
```{r}
valbirse_alti <- valbirse_gc |> 
  mutate(hoehe = terra::extract(alti, valbirse_gc)) # extract values froam a Raster for a set of locations.

# posmo_annotated <- na.omit(posmo_annotated)

valbirse_alti <- valbirse_alti[order(valbirse_alti$datetime, decreasing = FALSE),]

ggplot(data= valbirse_alti, aes(datetime, hoehe$altivrt))+
  geom_point(aes(color = groundcover))+
  geom_path()+
  labs(title = "Height change over time and ground cover of trajectory", subtitle = "Valbirse 05-07")+
  ylab("altitude [m.a.s.l.]")+
  xlab("time")
```

in this last visualization we can see very clearly, that the combination
of ground type and elevation will probably make for great criteria to
filter the pattern. In order to filter it from hiking, we will further
add the speed. But first, it needs to be defined that we only want
downhill movements on not paved roads for the further evaluation.

That the height difference is clearly visible, we will compute the
height difference every half minute, which equals 4 points.

```{r}
valbirse_alti <- valbirse_alti|> 
  mutate(
    h_plus1 = (lead(hoehe$altivrt) -hoehe$altivrt),
    h_plus2 = (lead(hoehe$altivrt, 2)- hoehe$altivrt),
    h_plus3 = (lead(hoehe$altivrt, 3)- hoehe$altivrt),
    h_plus4 = (lead(hoehe$altivrt, 4)- hoehe$altivrt)
  )

## uphill or downhill

## where sum is smaller than 0 we have a descent
valbirse_alti <- valbirse_alti |> 
  mutate(mtb_elevation = h_plus4 < 0)

# valbirse_alti <- valbirse_alti |> 
#   mutate(mtb_elevation = elevmean < 0)

tm_shape(valbirse_alti)+
  tm_dots("mtb_elevation")
```

elevation does exclude cable car, even though the movement should be uphill.

## Combination of criteria

If the sum of the 30 seconds movement block is negative and the
groundtype is either Acker, Wiese, Weide or else geschlossener Wald oder
übrige humusierte, it must be checked with the speed to determine if
these criteria match mountainbiking.

```{r}
valbirse <- valbirse_alti |> 
  select(datetime, ID, mtb_speed, mtb_gc, mtb_elevation, X, Y, geometry) |> 
  rowwise() |> 
  mutate(mtb = sum(mtb_speed, mtb_gc, mtb_elevation, na.rm=TRUE)) |> 
  ungroup()

head(valbirse)


tm_shape(valbirse)+
  tm_dots("mtb", palette= brewer.pal(4, "BrBG"))

length(valbirse$mtb_speed[valbirse$mtb_speed == TRUE]) # 184 true (of 1015 rows)
length(valbirse$mtb_gc[valbirse$mtb_gc == TRUE]) # 329 true
length(valbirse$mtb_elevation[valbirse$mtb_elevation == TRUE]) # 290 true


valbirse <- valbirse |> 
  mutate(mtb_count3 = mtb == 3)

length(valbirse$mtb_count3[valbirse$mtb_count3 == TRUE]) # 61 true

valbirse_summary <- valbirse |> 
  select(ID, mtb) |> 
  group_by(ID) |> 
  summarise(n_1 = sum(mtb==3),
            n_2 = sum(mtb==2),
            n_3 = sum(mtb==1)
            # sumcriteria = sum(mtb),
            # tourtime=difftime(last(datetime), first(datetime))
            )

valbirse_sumlong <- pivot_longer(valbirse_summary, 2:4,
               names_to = "criteria",
               values_to = "points")

# ggplot(valbirse_sumlong, aes(fill = criteria, x = ID, y = points)) +
#   geom_bar(position = "dodge", stat = "identity")+
#   scale_fill_manual(values = c("n_1" = "#dfc27d",
#                                "n_2" = "#80cdc1",
#                                "n_3" = "#018571"
#                                ))

ggplot(valbirse_sumlong, aes(fill = criteria, x = ID, y = points)) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = c("n_1" = "#dfc27d",
                               "n_2" = "#80cdc1",
                               "n_3" = "#018571"
                               ))+
  xlab("Segment ID")+
  ylab("number of points on trajectory")+
  labs(title = "Number of criteria applying to segments", subtitle = "Wiriehorn 05-18")+
  geom_text(data=subset(valbirse_sumlong,points > 5), aes(label = points), stat = "identity", colour = "black", position = position_stack(vjust = 0.5), size=2)
```


#### new segmentation
```{r}

valbirse_try <- valbirse |> 
  mutate(
    min3 = lead(mtb_count3) == TRUE |lead(mtb_count3,2)==TRUE |lead(mtb_count3,3) == TRUE | lag(mtb_count3) == TRUE | lag(mtb_count3,2)==TRUE | lag(mtb_count3,3)==TRUE
  ) # innerhalb einer minute muss mindestens einmal der Wert drei vorkommen - also drei kriterien erfüllt sein. 

tm_shape(valbirse_try)+
  tm_dots("min3")

valbirse_try <- valbirse_try |>
  mutate(
    c_plus1 = lead(mtb),
    c_plus2 = lead(mtb,2), # new offset of 2 in function lead()
    c_minus1 = lag(mtb),
    c_minus2 = lag(mtb,2)
  ) # berechnen, wie viele kriterien bei den benachbarten punkten zutreffen und so versuchen, die punkte wo weniger kriterien zutreffen, aussschliessen. ausreichend bike punkte eingeschlossen, die nicht alle kriterien erfüllen

valbirse_try <- valbirse_try |> 
  rowwise() |> 
  mutate(c_sum = sum(c(c_plus1, c_plus2, c_minus1, c_minus2))) |> 
  ungroup()

valbirse_try <- valbirse_try |> 
  mutate(mtb_sum = c_sum >= 6) |> 
  mutate(lastsegm = mtb_sum == TRUE & min3 == TRUE)

tm_shape(valbirse_try)+
  tm_dots("mtb_sum")

tm_shape(valbirse_try)+
  tm_dots("lastsegm")

valbirse_try <- valbirse_try |> 
  mutate(ID_mtb=rle_id(lastsegm))

valbirse_try <- valbirse_try |>
  filter(lastsegm==TRUE) # select rows where the criteria for the last segmentation are considered TRUE to select the moving segments

ggplot(valbirse_try, aes(X, Y))+
  geom_path(aes(color=ID_mtb))+
  geom_point(aes(color = ID_mtb))+
  coord_fixed()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```


